diff -rc pine4.61/imap/src/c-client/nntp.c pine4.61-cumulative/imap/src/c-client/nntp.c
*** pine4.61/imap/src/c-client/nntp.c	2004-07-08 15:02:03.000000000 -0700
--- pine4.61-cumulative/imap/src/c-client/nntp.c	2005-02-22 14:01:51.000000000 -0800
***************
*** 2166,2168 ****
--- 2166,2194 ----
  				/* output remainder of text */
    return *s ? net_soutr (stream,s) : T;
  }
+ 
+ /* overrides the newsrc assigned by nntp_mopen 
+  * Yes, I know...
+  */
+ 
+ char *change_newsrc(MAILSTREAM *stream,char *oldnewsrc, int option)
+ {
+   char *s = NULL;
+ 
+   if (!LOCAL)
+     return s;
+ 
+   if (LOCAL->newsrc){
+      s = cpystr(LOCAL->newsrc);
+      fs_give((void **)&LOCAL->newsrc);
+   }
+   if (option == 1)	/* return .newsrc file */
+      LOCAL->newsrc = cpystr((char *) mail_parameters (NIL,GET_NEWSRC,NIL));
+   else			/* return .newsrc-server file */
+      LOCAL->newsrc = cpystr(oldnewsrc);
+ 
+   if (oldnewsrc)
+      fs_give((void **)&oldnewsrc);
+ 
+   return s;
+ }
diff -rc pine4.61/pico/ebind.h pine4.61-cumulative/pico/ebind.h
*** pine4.61/pico/ebind.h	2004-05-07 14:38:24.000000000 -0700
--- pine4.61-cumulative/pico/ebind.h	2005-02-22 14:02:00.000000000 -0800
***************
*** 102,107 ****
--- 102,108 ----
  	{CTRL|'Z',		bktoshell},
  #endif
  	{CTRL|'@',		forwword},
+ 	{CTRL|'\\',		remove_trailing_quote},	/* same as ^4 */
  	{CTRL|'^',		setmark},
  	{CTRL|'_',		alt_editor},
  	{0x7F,			backdel},
diff -rc pine4.61/pico/efunc.h pine4.61-cumulative/pico/efunc.h
*** pine4.61/pico/efunc.h	2004-06-15 15:22:58.000000000 -0700
--- pine4.61-cumulative/pico/efunc.h	2005-02-22 14:02:00.000000000 -0800
***************
*** 172,177 ****
--- 172,178 ----
  extern	int lnewline PROTO((void));
  extern	int ldelete PROTO((long, int (*) PROTO((int))));
  extern	int lisblank PROTO((struct LINE *));
+ extern	int lequals PROTO((struct LINE *, char *));
  extern	void kdelete PROTO((void));
  extern	int kinsert PROTO((int));
  extern	int kremove PROTO((int));
***************
*** 289,294 ****
--- 290,296 ----
  extern	int quickexit PROTO((int, int));
  extern	int abort_composer PROTO((int, int));
  extern	int suspend_composer PROTO((int, int));
+ extern	int remove_trailing_quote PROTO((void));
  extern	int wquit PROTO((int, int));
  extern	int ctrlg PROTO((int, int));
  extern	int rdonly PROTO((void));
diff -rc pine4.61/pico/estruct.h pine4.61-cumulative/pico/estruct.h
*** pine4.61/pico/estruct.h	2004-06-15 15:22:58.000000000 -0700
--- pine4.61-cumulative/pico/estruct.h	2005-02-22 14:02:00.000000000 -0800
***************
*** 207,212 ****
--- 207,213 ----
  #define KS_SELECTCUR
  #define KS_UNDO
  #define KS_SPELLCHK
+ #define KS_REPLYALL
  #endif
  
  
diff -rc pine4.61/pico/line.c pine4.61-cumulative/pico/line.c
*** pine4.61/pico/line.c	2004-05-07 14:41:16.000000000 -0700
--- pine4.61-cumulative/pico/line.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 647,652 ****
--- 647,673 ----
  
  
  /*
+  * Returns true if the given line is the same as the given text, false
+  * otherwise.
+  */
+ int lequals(line, text)
+      struct LINE *line;
+      char *text;
+ {
+     int i;
+ 
+     if(llength(line) != strlen(text))
+ 	return(FALSE);
+ 
+     for(i = 0; i < llength(line); i++)
+       if(lgetc(line, i).c != text[i])
+ 	return(FALSE);
+ 
+     return(TRUE);
+ }
+    
+ 
+ /*
   * Delete all of the text saved in the kill buffer. Called by commands when a
   * new kill context is being created. The kill buffer array is released, just
   * in case the buffer has grown to immense size. No errors.
diff -rc pine4.61/pico/msmenu.h pine4.61-cumulative/pico/msmenu.h
*** pine4.61/pico/msmenu.h	1998-02-27 16:10:30.000000000 -0800
--- pine4.61-cumulative/pico/msmenu.h	2005-02-22 14:02:00.000000000 -0800
***************
*** 94,101 ****
  #define KS_SELECTCUR		    196
  #define KS_UNDO			    197
  #define KS_SPELLCHK		    198
  
! #define KS_RANGEEND		198
  
  #define KS_COUNT	    ((KS_RANGEEND - KS_RANGESTART) + 1)
  
--- 94,102 ----
  #define KS_SELECTCUR		    196
  #define KS_UNDO			    197
  #define KS_SPELLCHK		    198
+ #define KS_REPLYALL                 199
  
! #define KS_RANGEEND		199
  
  #define KS_COUNT	    ((KS_RANGEEND - KS_RANGESTART) + 1)
  
diff -rc pine4.61/pico/pico.c pine4.61-cumulative/pico/pico.c
*** pine4.61/pico/pico.c	2004-07-12 15:17:06.000000000 -0700
--- pine4.61-cumulative/pico/pico.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 74,79 ****
--- 74,80 ----
  void	breplace PROTO((void *));
  int	any_header_changes PROTO((void));
  int     cleanwhitespace PROTO((void));
+ void    reverse_skip PROTO((char *));
  #ifdef	_WINDOWS
  int	composer_file_drop PROTO((int, int, char *));
  #endif
***************
*** 676,681 ****
--- 677,684 ----
  int f, n;
  {
      register int    s;
+     char *buf_before_send = NULL;
+     int buflen = 0;
  
      if(Pmaster){
  	char *result;
***************
*** 691,696 ****
--- 694,703 ----
  	  if(spell(0, 0) == -1)
  	    sleep(3);    /* problem, show error */
  #endif
+ 
+ 	if(Pmaster->remove_trailing_quote)
+ 	   remove_trailing_quote();
+ 
  	/*
  	 * if we're not in header, show some of it as we verify sending...
  	 */
***************
*** 702,707 ****
--- 709,716 ----
  					     redraw_pico_for_callback,
  					     Pmaster->allow_flowed_text))){
  	    Pmaster->arm_winch_cleanup--;
+ 	    if(Pmaster->remove_trailing_quote)
+ 	      yank(0, 1);			/* put removed quote back */
  	    if(sgarbf)
  	      update();
  
***************
*** 870,875 ****
--- 879,993 ----
  }
  
  /*
+  * Examines the composition to see if it ends with a trailing quote. If it
+  * does, the trailing quote is removed (to the kill buffer).
+  *
+  * A quote is a piece of quoted text from an email that the user is replying
+  * to; each line of the quote is prefixed with Pmaster->quote_str, usually '>'.
+  * Quotes may span multiple lines. A quote is considered trailing if it is the
+  * last piece of text in the composition, disregarding whitespace and the
+  * signature.
+  *
+  * Returns true if a quote was removed, false otherwise.
+  *
+  * TODO: what if trailing quote starts on the first line of the buffer?
+  */
+ int
+ remove_trailing_quote()
+ {
+     char quote_buf[1], *sig;
+     int sig_len = strlen(Pmaster->sig);
+ 
+     kdelete();			/* clear the kill and justify buffers */
+     fdelete();
+     lastflag &= ~CFFILL;
+ 
+     /* prepend a newline to the sig, so that we handle single-line sigs ok */
+     sig = (char *)malloc((sig_len + 2) * sizeof(char));
+     sig[0] = '\n';
+     strncpy(sig + 1, Pmaster->sig, sig_len);
+     sig[sig_len + 1] = '\0';
+ 
+     /* start from the end, but above the signature (if it's there) */
+     reverse_skip(sig);
+     free(sig);
+     gotobol(0, 0);
+     forwline(0, 1);		/* since we added a newline to the sig */
+     setmark(0, 0);
+ 
+     /* search backward for a quoted line. if we hit a non-blank, non-quoted
+      * line, abort. */
+     while (curwp->w_dotp != curwp->w_linep){
+ 	if(lisblank(curwp->w_dotp)){
+ 	    backline(0, 1);
+ 	    continue;
+ 	}
+ 	else if(quote_match(Pmaster->quote_str, curwp->w_dotp, quote_buf, 1))
+ 	    break;
+ 	else{
+ 	    setmark(0, 0);		/* unset the mark */
+ 	    emlwrite("No trailing quote.", NULL);
+ 	    return(FALSE);
+ 	}
+     }
+ 
+     if(curwp->w_dotp == curwp->w_linep){
+ 	setmark(0, 0);			/* unset the mark */
+ 	emlwrite("No trailing quote.", NULL);
+ 	return(FALSE);
+     }
+ 
+     /* work backward to find the first line of this quote */
+     while (quote_match(Pmaster->quote_str, curwp->w_dotp, quote_buf, 1))
+ 	backline(0, 1);
+ 
+     /* if the lines immediately preceding the quote are a blank line and the
+      * reply leadin line, then this quote is whole, not trailing, so abort.
+      */
+     if(Pmaster->reply_leadin &&
+        lisblank(curwp->w_dotp) &&
+        lequals(lback(curwp->w_dotp), Pmaster->reply_leadin)){
+ 	setmark(0, 0);			/* unset the mark */
+ 	emlwrite("Last quote is whole, not trailing.", NULL);
+ 	return(FALSE);
+     }
+ 
+     /* also kill any blank lines between sig and text */
+     while (lisblank(curwp->w_dotp))
+ 	backline(0, 1);
+ 
+     forwline(0, 1);
+     killregion(0, 0);
+     PaintBody(0);
+     emlwrite("Removed trailing quote. To undo, press ^U.", NULL);
+     return(TRUE);
+ }
+ 
+ 
+ /*
+  * Searches the buffer contents for the given text (which may have embedded
+  * newlines). If found, skips the cursor above the text. Otherwise, leaves the
+  * cursor at the bottom of the buffer.
+  */
+ void
+ reverse_skip(text)
+ char *text;
+ {
+     int found = FALSE, wrapped = FALSE;
+ 
+     gotobob(0, 0);
+     /* search until we find it or we wrap (hence it's not found) */
+     while (!found && !wrapped)
+ 	found = forscan(&wrapped, text, NULL, 0, 1 /* PTBEG */);
+ 
+     if(found)
+ 	backline(0, 1);
+     else
+ 	gotoeob(0, 0);
+ }
+ 
+ 
+ /*
   * Abort.
   * Beep the beeper. Kill off any keyboard macro, etc., that is in progress.
   * Sometimes called as a routine, to do general aborting of stuff.
diff -rc pine4.61/pico/pico.h pine4.61-cumulative/pico/pico.h
*** pine4.61/pico/pico.h	2004-07-09 13:31:54.000000000 -0700
--- pine4.61-cumulative/pico/pico.h	2005-02-22 14:02:00.000000000 -0800
***************
*** 186,192 ****
--- 186,194 ----
      char  *pine_version;		/* string containing Pine's version */
      char  *oper_dir;			/* Operating dir (confine to tree) */
      char  *home_dir;                    /* Home directory that should be used (WINDOWS) */
+     char  *reply_leadin;		/* leadin before quoted text, or NULL*/
      char  *quote_str;			/* prepended to lines of quoted text */
+     char  *sig;				/* signature, may be NULL */
      char  *exit_label;			/* Label for ^X in keymenu */
      char  *ctrlr_label;			/* Label for ^R in keymenu */
      char  *alt_spell;			/* Checker to use other than "spell" */
***************
*** 203,208 ****
--- 205,211 ----
      unsigned always_spell_check:1;      /* always spell-checking upon quit */
      unsigned strip_ws_before_send:1;    /* don't default strip bc of flowed */
      unsigned allow_flowed_text:1;    /* clean text when done to keep flowed */
+     unsigned remove_trailing_quote:1;   /* remove trailing quote on send */
      int   (*helper)();			/* Pine's help function  */
      int   (*showmsg)();			/* Pine's display_message */
      int   (*suspend)();			/* Pine's suspend */
diff -rc pine4.61/pico/resource.h pine4.61-cumulative/pico/resource.h
*** pine4.61/pico/resource.h	2003-08-22 16:58:22.000000000 -0700
--- pine4.61-cumulative/pico/resource.h	2005-02-22 14:02:00.000000000 -0800
***************
*** 96,101 ****
--- 96,102 ----
  #define IDM_MI_SELECTCUR                196
  #define IDM_MI_UNDO                     197
  #define IDM_MI_SPELLCHK                 198
+ #define IDM_MI_REPLY_ALL                199
  #define	IDM_OPT_CARETBLOCK		200
  #define	IDM_OPT_CARETSMALLBLOCK		201
  #define	IDM_OPT_CARETHBAR		202
diff -rc pine4.61/pine/adrbkcmd.c pine4.61-cumulative/pine/adrbkcmd.c
*** pine4.61/pine/adrbkcmd.c	2004-07-12 19:26:14.000000000 -0700
--- pine4.61-cumulative/pine/adrbkcmd.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 4481,4488 ****
  
      gf_clear_so_writec((STORE_S *) pb->contents.text.data);
  
!     pine_send(outgoing, &body, "FORWARDING ADDRESS BOOK ENTRY", role, NULL,
!  	      NULL, NULL, NULL, NULL, 0);
      
      ps->mangled_screen = 1;
      ret = 1;
--- 4481,4488 ----
  
      gf_clear_so_writec((STORE_S *) pb->contents.text.data);
  
!     pine_send(NULL, outgoing, &body, "FORWARDING ADDRESS BOOK ENTRY", role,
! 	      NULL, NULL, NULL, NULL, NULL, 0);
      
      ps->mangled_screen = 1;
      ret = 1;
diff -rc pine4.61/pine/folder.c pine4.61-cumulative/pine/folder.c
*** pine4.61/pine/folder.c	2004-07-12 19:26:16.000000000 -0700
--- pine4.61-cumulative/pine/folder.c	2005-02-22 14:01:51.000000000 -0800
***************
*** 94,100 ****
  #define	FLW_SLCT	0x02
  #define	FLW_LIST	0x04
  
! 
  
  
  /*----------------------------------------------------------------------
--- 94,100 ----
  #define	FLW_SLCT	0x02
  #define	FLW_LIST	0x04
  
! static int max_slot_size = 0;
  
  
  /*----------------------------------------------------------------------
***************
*** 224,229 ****
--- 224,230 ----
  				   gf_io_t, HANDLE_S **, int));
  int	   folder_list_write_folder PROTO((gf_io_t, CONTEXT_S *,
  					   int, char *, int));
+ int	   folder_list_write_count PROTO((FOLDER_S *, CONTEXT_S *, gf_io_t, int));
  int	   folder_list_write_prefix PROTO((FOLDER_S *, int, gf_io_t));
  int	   folder_list_ith PROTO((int, CONTEXT_S *));
  char	  *folder_list_center_space PROTO((char *, int));
***************
*** 468,474 ****
  
  	HELP_MENU,
  	OTHER_MENU,
! 	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
--- 469,475 ----
  
  	HELP_MENU,
  	OTHER_MENU,
!         {"^H","ChkIncFld",{MC_FORCECHECK,1,ctrl('H')}, KS_NONE},
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
***************
*** 1681,1686 ****
--- 1682,1688 ----
      gf_io_t	pc;
  
      dprint(1, (debugfile, "\n\n    ---- FOLDER LISTER ----\n"));
+     ps->in_fld_list = 1;
  
      memset(&folder_proc_data, 0, sizeof(FPROC_S));
      folder_proc_data.fs = fs;
***************
*** 1801,1806 ****
--- 1803,1809 ----
      if(folder_proc_data.all_done)
        fs->context = NULL;
  
+     ps->in_fld_list = 0;
      return(folder_proc_data.rv);
  }
  
***************
*** 1914,1919 ****
--- 1917,1934 ----
  		gf_puts("\n", pc);
  	    }
  
+ 	    if (c_list->use & CNTXT_INCMNG &&
+ 		F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 		F_ON(F_ENABLE_INCOMING,ps_global) &&
+ 		F_OFF(F_ENABLE_FAST_RECENT, ps_global)){
+ 		sprintf(tmp_20k_buf, 
+ 		   "Format: Folder-name [Total New Messages/Total Messages]");
+ 		gf_puts(folder_list_center_space(tmp_20k_buf, cols), pc);
+ 		gf_puts(tmp_20k_buf, pc);
+ 		gf_puts("\n", pc);
+ 	    }
+ 
+ 
  	    gf_puts(repeat_char(cols, '-'), pc);
  	    gf_puts("\n\n", pc);
  	}
***************
*** 1951,1958 ****
--- 1966,1986 ----
  		    else if(c_list == fp->fs->list_cntxt)
  		      len += 4;			/* "[X] " */
  
+ 		    if (c_list->use & CNTXT_INCMNG &&
+ 			F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 			F_ON(F_ENABLE_INCOMING,ps_global) &&
+ 			F_OFF(F_ENABLE_FAST_RECENT, ps_global))
+ 			if (need_folder_report(FLDR_NAME(f))){
+ 			   len += 5;		/* "[/]" + "  " */
+ 			   len += strlen(comatose(f->countrecent));
+ 			   len += strlen(comatose(f->messages));
+ 			}
+ 			else
+ 			   len += 1;
+ 
  		    if(slot_size < len)
  		      slot_size = len;
+ 		    max_slot_size = slot_size;
  		}
  
  		if(F_ON(F_SINGLE_FOLDER_LIST, ps_global)){
***************
*** 2057,2063 ****
      int	       flags;
  {
      char      buf[256];
!     int	      l = 0;
      FOLDER_S *fp;
      HANDLE_S *h;
  
--- 2085,2091 ----
      int	       flags;
  {
      char      buf[256];
!     int	      l = 0, s = 0;
      FOLDER_S *fp;
      HANDLE_S *h;
  
***************
*** 2080,2085 ****
--- 2108,2114 ----
  	     && (*pc)(strlen(buf)) && gf_puts(buf, pc)) : 1)
         && (fp ? ((l = folder_list_write_prefix(fp, flags, pc)) >= 0
  		 && gf_puts(FLDR_NAME(fp), pc)
+ 		 && (s = folder_list_write_count(fp, ctxt, pc, l)) >= 0
  		 && ((fp->isdir && fp->isfolder) ? (*pc)('[') : 1)
  		 && ((fp->isdir) ? (*pc)(ctxt->dir->delim) : 1)
  		 && ((fp->isdir && fp->isfolder) ? (*pc)(']') : 1))
***************
*** 2087,2093 ****
         && (h ? ((*pc)(TAG_EMBED) && (*pc)(TAG_BOLDOFF)
  		&& (*pc)(TAG_EMBED) && (*pc)(TAG_INVOFF)) : 1)){
  	if(fp){
! 	    l += strlen(FLDR_NAME(fp));
  	    if(fp->isdir)
  	      l += (fp->isfolder) ? 3 : 1;
  	}
--- 2116,2122 ----
         && (h ? ((*pc)(TAG_EMBED) && (*pc)(TAG_BOLDOFF)
  		&& (*pc)(TAG_EMBED) && (*pc)(TAG_INVOFF)) : 1)){
  	if(fp){
! 	    l += strlen(FLDR_NAME(fp)) + s;
  	    if(fp->isdir)
  	      l += (fp->isfolder) ? 3 : 1;
  	}
***************
*** 2098,2103 ****
--- 2127,2162 ----
      return(l);
  }
  
+ int
+ folder_list_write_count(f, ctxt, pc, l)
+     FOLDER_S *f;
+     CONTEXT_S *ctxt;
+     gf_io_t   pc;
+     int	      l;
+ {
+     int rv = 0, i;
+     int offset = 1;
+ 
+     if (ctxt->use & CNTXT_INCMNG &&
+ 	F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 	F_ON(F_ENABLE_INCOMING,ps_global) &&
+ 	F_OFF(F_ENABLE_FAST_RECENT, ps_global) && 
+ 	need_folder_report(FLDR_NAME(f))){
+ 	   rv  = max_slot_size - strlen(FLDR_NAME(f)) - l;
+ 	   rv -= strlen(comatose(f->countrecent));
+  	   rv -= strlen(comatose(f->messages));
+ 	   rv -= 5 + offset;
+ 	   for (i = 0; i <= rv; i++) gf_puts(" ", pc);
+ 	   gf_puts("[", pc);
+ 	   gf_puts(comatose(f->countrecent), pc);
+ 	   gf_puts("/", pc);
+ 	   gf_puts(comatose(f->messages), pc);
+ 	   gf_puts("]", pc);
+ 	   rv = max_slot_size - strlen(FLDR_NAME(f)) - l - offset -1;
+     }
+     return rv;
+ }
+ 
  
  int
  folder_list_write_prefix(f, flags, pc)
***************
*** 2415,2421 ****
  			   "Empty folder collection.  No folder to rename!");
  
  	break;
! 		     
  
              /*-------------- Delete --------------------*/
        case MC_DELETE :
--- 2474,2489 ----
  			   "Empty folder collection.  No folder to rename!");
  
  	break;
! 
! 
! 		/*------- Check incoming forlders -------*/
!       case MC_FORCECHECK:
! 	   ps_global->force_check_now = 1;
! 	   rv = (new_mail_incfolder(ps_global,MC_FORCECHECK) &&
! 		 ps_global->refresh_list > 0) ? 1 : 0;
! 	   ps_global->refresh_list = 0;
! 	break;
! 
  
              /*-------------- Delete --------------------*/
        case MC_DELETE :
***************
*** 3205,3212 ****
  	  case 'f' :			/* flip selection */
  	    n = folder_total(FOLDERS(context));
  	    for(total = i = 0; i < n; i++)
! 	      if(f = folder_entry(i, FOLDERS(context)))
  		f->selected = !f->selected;
  
  	    return(1);			/* repaint */
  
--- 3273,3282 ----
  	  case 'f' :			/* flip selection */
  	    n = folder_total(FOLDERS(context));
  	    for(total = i = 0; i < n; i++)
! 	      if(f = folder_entry(i, FOLDERS(context))){
  		f->selected = !f->selected;
+ 		f->user_selected = f->selected;
+ 	      }
  
  	    return(1);			/* repaint */
  
***************
*** 3349,3363 ****
      CONTEXT_S *context;
  {
      int	      i, n, total;
  
      n = folder_total(FOLDERS(context));
!     for(total = i = 0; i < n; i++)
!       if(folder_entry(i, FOLDERS(context))->selected)
  	total++;
  
      return(total);
  }
  
  
  SELECTED_S *
  new_selected()
--- 3419,3478 ----
      CONTEXT_S *context;
  {
      int	      i, n, total;
+     FOLDER_S  *f;
  
      n = folder_total(FOLDERS(context));
!     for(total = i = 0; i < n; i++){
!       f = folder_entry(i, FOLDERS(context));
!       if(f->selected) 
  	total++;
+     }
  
      return(total);
  }
  
+ void
+ update_incoming_folder_data(stream, context)
+  MAILSTREAM *stream;
+  CONTEXT_S  *context;
+ {
+  FOLDER_S *f = incoming_folder_data(stream, context);
+ 
+   if(f){
+      f->origrecent = f->recent = stream->recent;
+      f->messages   = stream->nmsgs;
+   }
+ }
+ 
+ 
+ FOLDER_S *
+ incoming_folder_data(stream, cntxt)
+  MAILSTREAM *stream;
+  CONTEXT_S  *cntxt;
+ {
+    long index, total;
+    FOLDER_S *f = NULL;
+ 
+    if (cntxt && cntxt->use & CNTXT_INCMNG){
+       total = folder_total(FOLDERS(cntxt));
+       for (index = 0L; index < total ; index++){ 
+ 	 f = folder_entry(index, FOLDERS(cntxt));
+ 	 if (!strcmp(STREAMNAME(stream), FLDR_NAME(f)))
+ 	     break;
+       }
+    }
+    return f;
+ }
+ 
+ int
+ need_folder_report(folder)
+   char *folder;
+ {
+   return (ps_global->VAR_INCOMING_FOLDERS_CHECK &&
+ 	 ((ps_global->VAR_INCOMING_FOLDERS_CHECK[0] == '*') ||
+ 	  strstr(ps_global->VAR_INCOMING_FOLDERS_CHECK, folder)));
+ }
+ 
  
  SELECTED_S *
  new_selected()
***************
*** 4087,4092 ****
--- 4202,4208 ----
  
      if(f = folder_entry(index, FOLDERS(context))){
        f->selected = !f->selected;
+       f->user_selected = f->selected;
        return((*func)(context, index));
      }
      return 1;
***************
*** 7098,7103 ****
--- 7214,7222 ----
      FOLDERS(context) = init_folder_entries();
      init_incoming_folder_list(ps_global, context);
      init_inbox_mapping(ps_global->VAR_INBOX_PATH, context);
+     ps_global->force_check_now = 1;	/* sorry about this */
+     new_mail_incfolder(ps_global,MC_FORCECHECK);
+     ps_global->refresh_list += 1;
  }
  
  
***************
*** 8449,8454 ****
--- 8568,8710 ----
  
  
  /*
+  * next_folder - given a current folder in a context, return the next in
+  *               the list, or NULL if no more or there's a problem.
+  */
+ char *
+ next_folder_check(streamp, cntxt, find_recent, find_messages, f, opstrm)
+     MAILSTREAM **streamp;
+     CONTEXT_S	*cntxt;
+     long	*find_recent, *find_messages;
+     FOLDER_S 	*f;
+     int		*opstrm;
+ {
+     char      *next;
+     int       index, recent = 0, failed_status = 0;
+     char      *star = "*";
+     char      *oldnewsrc = NULL;
+ 
+     /* note: find_folders may assign "stream" */
+     build_folder_list(streamp, cntxt, NULL, NULL,
+ 		      NEWS_TEST(cntxt) ? BFL_LSUB : BFL_NONE);
+ 
+     if(find_recent && find_messages && opstrm){
+       MAILSTREAM *stream = NULL;
+       int         rv, we_cancel = 0;
+       char        msg_buf[MAX_SCREEN_COLS+1] = {'\0'};
+       char        tmp[MAILTMPLEN];
+ 
+       *opstrm	     = 0;		/* default value */
+       *find_recent   = f->recent;	/* default value. Return this if */
+       *find_messages = f->messages;	/* not requested		 */
+ 
+       if((stream = sp_stream_get(context_apply(tmp, cntxt, f->name,sizeof(tmp)),
+ 						     SP_MATCH)) != NULL){
+ 	  *opstrm = 1;
+ 	  (void) pine_mail_ping(stream);
+ 	  next = new_mail_in_open_stream(stream, find_recent, find_messages);
+ 	  free_folder_list(cntxt);
+ 	  return next;
+       } 
+       else if ((F_ON(F_ENABLE_FAST_RECENT, ps_global) &&
+ 		F_OFF(F_ENABLE_INCOMING_RECHECK,ps_global)  && 
+ 		(folder_in_message_list(FLDR_NAME(f)) || f->selected))
+ 		|| (f->selected && f->user_selected)){
+ 
+ 	  next = folder_in_message_list(FLDR_NAME(f)) ? cpystr(FLDR_NAME(f)) 
+ 						      : NULL;
+ 	  free_folder_list(cntxt);
+ 	  return next;
+       }
+       else if (need_folder_report(FLDR_NAME(f))
+ 		&& (strcmp(ps_global->cur_folder, FLDR_NAME(f)) || !stream)){
+ 
+ 	  we_cancel = busy_alarm(1, msg_buf, NULL, 1);
+ 
+ 	  /* First, get a stream for the test */
+ 	  if(streamp && *streamp){
+ 	     if(context_same_stream(cntxt, f->name, *streamp))
+ 		stream = *streamp;
+ 	     else{
+ 		mail_close(*streamp);
+ 		*streamp = NULL;
+ 	     }
+ 	   }
+ 
+ 	  if(!stream)
+ 	      stream = sp_stream_get(context_apply(tmp, cntxt, f->name,
+ 						   sizeof(tmp)), SP_SAME);
+ 
+ 	  if (IS_NEWS(ps_global->mail_stream) 
+ 		&& F_ON(F_ENABLE_MULNEWSRCS,ps_global))
+ 	     oldnewsrc = (char *)change_newsrc(ps_global->mail_stream,oldnewsrc, 1);
+ 
+ 	  if(F_OFF(F_ENABLE_FAST_RECENT, ps_global)
+ 	     || !((rv = folder_exists(cntxt,f->name))
+ 					     & (FEX_ISMARKED | FEX_UNMARKED))){
+ 	      extern MAILSTATUS mm_status_result;
+ 
+ 	      if((F_ON(F_ENABLE_FAST_RECENT, ps_global) &&
+ 	          (rv == 0 || rv & FEX_ERROR))){
+ 		  failed_status = 1;
+ 		  mm_status_result.flags = 0L;
+ 	      }
+ 	      else{
+ 		  if(stream){
+ 		      if(!context_status_full(cntxt, stream,
+ 					      f->name, SA_RECENT | SA_MESSAGES,
+ 					      &f->uidvalidity,
+ 					      &f->uidnext)){
+ 			  failed_status = 1;
+ 			  mm_status_result.flags = 0L;
+ 		      }
+ 		  }
+ 		  else{
+ 		      if(!context_status_streamp_full(cntxt, streamp, f->name,
+ 						      SA_RECENT | SA_MESSAGES,
+ 						      &f->uidvalidity,
+ 						      &f->uidnext)){
+ 			  failed_status = 1;
+ 			  mm_status_result.flags = 0L;
+ 		      }
+ 		  }
+ 	      }
+ 
+ 	      if (!failed_status)
+ 		*find_messages = mm_status_result.messages;
+ 	      rv = (((mm_status_result.flags & SA_RECENT) ||
+ 		      (F_OFF(F_ENABLE_FAST_RECENT,ps_global) 
+ 			&& (mm_status_result.recent != f->recent)))
+ 		    && (*find_recent = mm_status_result.recent))
+ 		     ? FEX_ISMARKED : 0;
+ 	  }
+ 
+ 	  if (IS_NEWS(ps_global->mail_stream) 
+ 		&& F_ON(F_ENABLE_MULNEWSRCS,ps_global))
+ 	     oldnewsrc = (char *)change_newsrc(ps_global->mail_stream,oldnewsrc, 0);
+ 
+ 	  if (oldnewsrc)
+ 	     fs_give((void **)&oldnewsrc);
+ 
+ 	  if(we_cancel)
+ 	    cancel_busy_alarm(0);
+ 
+ 	  failed_status = 0;
+ 
+ 	  if(rv & FEX_ISMARKED){
+ 	    recent++;
+ 	    next = (f && (!find_recent || recent)) ? cpystr(FLDR_NAME(f)) : NULL;
+   	    free_folder_list(cntxt);
+     	    return(next);
+ 	  }
+       }
+       return(NULL);
+     }
+ }
+ 
+ 
+ 
+ /*
   * folder_is_nick - check to see if the given name is a nickname
   *                  for some folder in the given context...
   *
diff -rc pine4.61/pine/help.c pine4.61-cumulative/pine/help.c
*** pine4.61/pine/help.c	2004-04-08 09:59:19.000000000 -0700
--- pine4.61-cumulative/pine/help.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 1443,1449 ****
  	memset((void *)&fake_reply, 0, sizeof(fake_reply));
  	fake_reply.flags	   = REPLY_PSEUDO;
  	fake_reply.data.pico_flags = P_HEADEND;
! 	pine_send(outgoing, &body, composer_title, NULL, NULL,
  		  &fake_reply, NULL, NULL, pf, 0);
      }
      
--- 1443,1449 ----
  	memset((void *)&fake_reply, 0, sizeof(fake_reply));
  	fake_reply.flags	   = REPLY_PSEUDO;
  	fake_reply.data.pico_flags = P_HEADEND;
! 	pine_send(NULL, outgoing, &body, composer_title, NULL, NULL,
  		  &fake_reply, NULL, NULL, pf, 0);
      }
      
diff -rc pine4.61/pine/imap.c pine4.61-cumulative/pine/imap.c
*** pine4.61/pine/imap.c	2004-06-02 15:00:36.000000000 -0700
--- pine4.61-cumulative/pine/imap.c	2005-02-22 14:01:51.000000000 -0800
***************
*** 704,710 ****
      q_line = -(ps_global->ttyo ? ps_global->ttyo->footer_rows : 3);
  
      /* make sure errors are seen */
!     if(ps_global->ttyo)
        flush_status_messages(0);
  
      /*
--- 704,710 ----
      q_line = -(ps_global->ttyo ? ps_global->ttyo->footer_rows : 3);
  
      /* make sure errors are seen */
!     if((ps_global->ttyo) && (!ps_global->checking_incfld))
        flush_status_messages(0);
  
      /*
***************
*** 1938,1948 ****
  #endif
  
      if(elapsed >= (long)ps_global->tcp_query_timeout){
! 	sprintf(pmt,
! 	 "Waited %s seconds for server reply.  Break connection to server",
  		long2string(elapsed));
! 	if(want_to(pmt, 'n', 'n', NO_HELP, WT_FLUSH_IN) == 'y')
! 	  return(0L);
      }
  
      return(rv);
--- 1938,1952 ----
  #endif
  
      if(elapsed >= (long)ps_global->tcp_query_timeout){
! 	if (!ps_global->checking_incfld){
! 	  sprintf(pmt,
! 	   "Waited %s seconds for server reply.  Break connection to server",
  		long2string(elapsed));
! 	  if(want_to(pmt, 'n', 'n', NO_HELP, WT_FLUSH_IN) == 'y')
! 	    return(0L);
! 	}
! 	else
! 	   rv = 0L;
      }
  
      return(rv);
***************
*** 1984,2009 ****
      if(elapsed >= (long)ps_global->tcp_query_timeout){
  	int clear_inverse;
  
! 	ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
! 	if(clear_inverse = !InverseState())
! 	  StartInverse();
! 
! 	Writechar(BELL, 0);
! 
! 	PutLine1(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global), 0,
!        "Waited %s seconds for server reply.  Break connection to server? ",
! 	   long2string(elapsed));
! 	CleartoEOLN();
! 	fflush(stdout);
! 	flush_input();
! 	ch = read_char(7);
! 	if(ch == 'y' || ch == 'Y')
! 	  rv = 0L;
  
! 	if(clear_inverse)
! 	  EndInverse();
  
! 	ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
      }
  
      if(rv == 1L){			/* just warn 'em something's up */
--- 1988,2017 ----
      if(elapsed >= (long)ps_global->tcp_query_timeout){
  	int clear_inverse;
  
! 	if (!ps_global->checking_incfld){
! 	   ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
! 	   if(clear_inverse = !InverseState())
! 	     StartInverse();
! 
! 	   Writechar(BELL, 0);
! 
! 	   PutLine1(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global), 0,
!             "Waited %s seconds for server reply.  Break connection to server? ",
! 	     long2string(elapsed));
! 	   CleartoEOLN();
! 	   fflush(stdout);
! 	   flush_input();
! 	   ch = read_char(7);
! 	   if(ch == 'y' || ch == 'Y')
! 	     rv = 0L;
  
! 	   if(clear_inverse)
! 	     EndInverse();
  
! 	   ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
! 	}
! 	else
! 	   rv = 0L;
      }
  
      if(rv == 1L){			/* just warn 'em something's up */
diff -rc pine4.61/pine/init.c pine4.61-cumulative/pine/init.c
*** pine4.61/pine/init.c	2004-07-15 10:37:24.000000000 -0700
--- pine4.61-cumulative/pine/init.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 71,76 ****
--- 71,77 ----
  typedef enum {Sapling, Seedling, Seasoned} FeatureLevel;
  
  #define	TO_BAIL_THRESHOLD	60
+ #define	INCFLD_THRESHOLD	5
  
  #define METASTR "\nremote-abook-metafile="
  static char meta_prefix[] = ".ab";
***************
*** 158,163 ****
--- 159,166 ----
  
  CONF_TXT_T cf_text_incoming_folders[] =	"List of incoming msg folders besides INBOX, e.g. ={host2}inbox, {host3}inbox\n# Syntax: optnl-label {optnl-imap-host-name}folder-path";
  
+ CONF_TXT_T cf_incoming_folders_check[] = "List of incoming folders to be checked for new mail";
+ 
  CONF_TXT_T cf_text_folder_collections[] =	"List of directories where saved-message folders may be. First one is\n# the default for Saves. Example: Main {host1}mail/[], Desktop mail\\[]\n# Syntax: optnl-label {optnl-imap-hostname}optnl-directory-path[]";
  
  CONF_TXT_T cf_text_news_collections[] =	"List, only needed if nntp-server not set, or news is on a different host\n# than used for NNTP posting. Examples: News *[] or News *{host3/nntp}[]\n# Syntax: optnl-label *{news-host/protocol}[]";
***************
*** 240,245 ****
--- 243,250 ----
  
  CONF_TXT_T cf_text_inc_startup[] =	"Sets message which cursor begins on. Choices: first-unseen, first-recent,\n# first-important, first-important-or-unseen, first-important-or-recent,\n# first, last. Default: \"first-unseen\".";
  
+ CONF_TXT_T cf_text_inc_check[] =	"Sets how and when checks for new mail should happen. Choices: automatic,\n# automatic-after-first-manual-check, manual-only, Default: automatic";
+ 
  CONF_TXT_T cf_pruning_rule[] =		"Allows a default answer for the prune folder questions. Choices: yes-ask,\n# yes-no, no-ask, no-no, ask-ask, ask-no. Default: \"ask-ask\".";
  
  CONF_TXT_T cf_reopen_rule[] =		"Controls behavior when reopening an already open folder.";
***************
*** 368,373 ****
--- 373,380 ----
  
  CONF_TXT_T cf_text_tcp_query_timeo[] =	"If this much time has elapsed at the time of a tcp read or write\n# timeout, pine will ask if you want to break the connection.\n# Default is 60 seconds, minimum is 5, maximum is 1000.";
  
+ CONF_TXT_T cf_text_inc_fld_timeout[] =	"If this much time has elapsed at the time of a tcp read or write\n# timeout while checking for new mail in an incoming folder, pine will break the connection.\n# Default is 5 seconds, minimum is 2, maximum is 60.";
+ 
  CONF_TXT_T cf_text_rsh_open_timeo[] =	"Sets the time in seconds that Pine will attempt to open a UNIX remote\n# shell connection.  The default is 15, min is 5, and max is unlimited.\n# Zero disables rsh altogether.";
  
  CONF_TXT_T cf_text_rsh_path[] =		"Sets the name of the command used to open a UNIX remote shell connection.\n# The default is tyically /usr/ucb/rsh.";
***************
*** 461,466 ****
--- 468,475 ----
  				cf_text_nntp_server},
  {"inbox-path",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_inbox_path},
+ {"incoming-folders-to-check",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_incoming_folders_check},
  {"incoming-archive-folders",		0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
  				cf_text_archived_folders},
  {"pruned-folders",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
***************
*** 509,514 ****
--- 518,525 ----
  				cf_text_goto_default},
  {"incoming-startup-rule",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_inc_startup},
+ {"incoming-check-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_text_inc_check},
  {"pruning-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_pruning_rule},
  {"folder-reopen-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
***************
*** 651,656 ****
--- 662,669 ----
  				cf_text_tcp_write_timeo},
  {"tcp-query-timeout",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_tcp_query_timeo},
+ {"inc-fld-timeout",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_text_inc_fld_timeout},
  {"rsh-command",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
  				cf_text_rsh_command},
  {"rsh-path",				0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
***************
*** 1481,1486 ****
--- 1494,1500 ----
      GLO_REMOTE_ABOOK_VALIDITY	= cpystr(DF_REMOTE_ABOOK_VALIDITY);
      GLO_GOTO_DEFAULT_RULE	= cpystr(DF_GOTO_DEFAULT_RULE);
      GLO_INCOMING_STARTUP	= cpystr(DF_INCOMING_STARTUP);
+     GLO_INCOMING_RULE		= cpystr(DF_INCOMING_RULE);
      GLO_PRUNING_RULE		= cpystr(DF_PRUNING_RULE);
      GLO_REOPEN_RULE		= cpystr(DF_REOPEN_RULE);
      GLO_THREAD_DISP_STYLE	= cpystr(DF_THREAD_DISP_STYLE);
***************
*** 2051,2056 ****
--- 2065,2077 ----
      else
        ps->tcp_query_timeout = i;
  
+     set_current_val(&vars[V_INCFLDTIMEO], TRUE, TRUE);
+     ps->incfld_timeout = i = INCFLD_THRESHOLD;
+     if(VAR_INCFLDTIMEO && SVAR_INCFLDQUERY(ps, i, tmp_20k_buf))
+       init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
+     else
+       ps->incfld_timeout = i;
+ 
      set_current_val(&vars[V_NEWSRC_PATH], TRUE, TRUE);
      if(VAR_NEWSRC_PATH && VAR_NEWSRC_PATH[0])
        mail_parameters(NULL, SET_NEWSRC, (void *)VAR_NEWSRC_PATH);
***************
*** 2286,2291 ****
--- 2307,2313 ----
      set_current_val(&vars[V_PRUNED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_ARCHIVED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_INCOMING_FOLDERS], TRUE, TRUE);
+     set_current_val(&vars[V_INCOMING_FOLDERS_CHECK], TRUE, TRUE);
      set_current_val(&vars[V_SORT_KEY], TRUE, TRUE);
      if(decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev) == -1){
  	sprintf(tmp_20k_buf, "Sort type \"%.200s\" is invalid", VAR_SORT_KEY);
***************
*** 2323,2328 ****
--- 2345,2351 ----
      cur_rule_value(&vars[V_TITLEBAR_COLOR_STYLE], TRUE, TRUE);
      cur_rule_value(&vars[V_FLD_SORT_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_INCOMING_STARTUP], TRUE, TRUE);
+     cur_rule_value(&vars[V_INCOMING_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_PRUNING_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_REOPEN_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_GOTO_DEFAULT_RULE], TRUE, TRUE);
***************
*** 2573,2578 ****
--- 2596,2603 ----
  	 F_AUTO_REPLY_TO, h_config_auto_reply_to, PREF_RPLY},
  	{"signature-at-bottom",
  	 F_SIG_AT_BOTTOM, h_config_sig_at_bottom, PREF_RPLY},
+ 	{"separate-reply-all",
+ 	 F_SEPARATE_REPLY_ALL, h_config_separate_reply_all, PREF_RPLY},
  	{"strip-from-sigdashes-on-reply",
  	 F_ENABLE_STRIP_SIGDASHES, h_config_strip_sigdashes, PREF_RPLY},
  
***************
*** 2605,2610 ****
--- 2630,2637 ----
  	 F_WARN_ABOUT_NO_TO_OR_CC, h_config_warn_if_no_to_or_cc, PREF_SEND},
  	{"warn-if-blank-subject",
  	 F_WARN_ABOUT_NO_SUBJECT, h_config_warn_if_subj_blank, PREF_SEND},
+ 	{"remove-trailing-quote",
+ 	 F_REMOVE_TRAILING_QUOTE, h_config_remove_trailing_quote, PREF_SEND},
  
  /* Folder */
  	{"combined-subdirectory-display",
***************
*** 2615,2620 ****
--- 2642,2651 ----
  	 F_ENABLE_DOT_FOLDERS, h_config_enable_dot_folders, PREF_FLDR},
  	{"enable-incoming-folders",
  	 F_ENABLE_INCOMING, h_config_enable_incoming, PREF_FLDR},
+ 	{"enable-check-incoming-folders",
+ 	 F_ENABLE_INCOMING_CHECK, h_config_enable_check_incoming, PREF_FLDR},
+ 	{"recheck-all-incoming-folders",
+ 	 F_ENABLE_INCOMING_RECHECK, h_config_enable_recheck_incoming,PREF_FLDR},
  	{"enable-lame-list-mode",
  	 F_FIX_BROKEN_LIST, h_config_lame_list_mode, PREF_FLDR},
  	{"expanded-view-of-folders",
***************
*** 2688,2693 ****
--- 2719,2727 ----
  #endif
  	{"quell-charset-warning",
  	 F_QUELL_CHARSET_WARNING, h_config_quell_charset_warning, PREF_VIEW},
+ 	{"quell-displaying-flowed-text",
+ 	 F_QUELL_DISPLAYING_FLOWED_TEXT, h_config_quell_displaying_flowed_text,
+ 	 PREF_VIEW},
  
  /* News */
  	{"compose-sets-newsgroup-without-confirm",
***************
*** 3684,3689 ****
--- 3718,3740 ----
  	   ? &is_rules[index] : NULL);
  }
  
+ /*
+  * Standard way to get  incoming check rules...
+  */
+ NAMEVAL_S *
+ incoming_check_rules(index)
+     int index;
+ {
+     static NAMEVAL_S is_rules[] = {
+ 	{"automatic",				NULL, IC_AUTO},
+ 	{"automatic-after-first-manual-check",	NULL, IC_MAN_AUTO},
+ 	{"manual-only",				NULL, IC_MAN}
+     };
+ 
+     return((index >= 0 && index < (sizeof(is_rules)/sizeof(is_rules[0])))
+ 	   ? &is_rules[index] : NULL);
+ }
+ 
  
  NAMEVAL_S *
  startup_rules(index)
***************
*** 10899,10904 ****
--- 10950,10963 ----
  	      break;
  	  }
      }
+     else if(var == &ps_global->vars[V_INCOMING_RULE]){
+       if(ps_global->VAR_INCOMING_RULE)
+ 	for(i = 0; v = incoming_check_rules(i); i++)
+ 	  if(!strucmp(ps_global->VAR_INCOMING_RULE, S_OR_L(v))){
+ 	      ps_global->inc_check_rule = v->value;
+ 	      break;
+ 	  }
+     }
      else if(var == &ps_global->vars[V_PRUNING_RULE]){
        if(ps_global->VAR_PRUNING_RULE)
  	for(i = 0; v = pruning_rules(i); i++)
Only in pine4.61-cumulative/pine: init.c.orig
diff -rc pine4.61/pine/mailcmd.c pine4.61-cumulative/pine/mailcmd.c
*** pine4.61/pine/mailcmd.c	2004-07-13 18:35:15.000000000 -0700
--- pine4.61-cumulative/pine/mailcmd.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 59,65 ****
   */
  void      cmd_delete PROTO((struct pine *, MSGNO_S *, int, CmdWhere));
  void      cmd_undelete PROTO((struct pine *, MSGNO_S *, int));
! void      cmd_reply PROTO((struct pine *, MSGNO_S *, int));
  void      cmd_forward PROTO((struct pine *, MSGNO_S *, int));
  void      cmd_bounce PROTO((struct pine *, MSGNO_S *, int));
  void      cmd_print PROTO((struct pine *, MSGNO_S *, int, CmdWhere));
--- 59,65 ----
   */
  void      cmd_delete PROTO((struct pine *, MSGNO_S *, int, CmdWhere));
  void      cmd_undelete PROTO((struct pine *, MSGNO_S *, int));
! void      cmd_reply PROTO((struct pine *, MSGNO_S *, int, int));
  void      cmd_forward PROTO((struct pine *, MSGNO_S *, int));
  void      cmd_bounce PROTO((struct pine *, MSGNO_S *, int));
  void      cmd_print PROTO((struct pine *, MSGNO_S *, int, CmdWhere));
***************
*** 569,577 ****
  
            /*---------- Reply to message ----------*/
        case MC_REPLY :
! 	cmd_reply(state, msgmap, 0);
  	break;
  
  
            /*---------- Forward message ----------*/
        case MC_FORWARD :
--- 569,582 ----
  
            /*---------- Reply to message ----------*/
        case MC_REPLY :
! 	cmd_reply(state, msgmap, 0, (F_ON(F_SEPARATE_REPLY_ALL, ps_global)) ?
! 	                             RSF_NONE : RSF_QUERY_REPLY_ALL);
  	break;
  
+           /*---------- Reply-all to message ----------*/
+       case MC_REPLY_ALL :
+ 	cmd_reply(state, msgmap, 0, RSF_FORCE_REPLY_ALL);
+ 	break;
  
            /*---------- Forward message ----------*/
        case MC_FORWARD :
***************
*** 1224,1229 ****
--- 1229,1235 ----
  	ps_global->expunge_in_progress = 0;
  	if(we_cancel)
  	  cancel_busy_alarm((sp_expunge_count(stream) > 0) ? 0 : -1);
+ 	update_incoming_folder_data(stream, state->context_current);
  
  	dprint(2,(debugfile,"expunge complete cur:%ld max:%ld\n",
  		  mn_get_cur(msgmap), mn_get_total(msgmap)));
***************
*** 1500,1505 ****
--- 1506,1517 ----
  	break;
  
  
+          /*--------Incoming Folders Auto Check --------*/
+       case MC_FORCECHECK:
+ 	state->force_check_now = 1;
+ 	new_mail_incfolder(state,command);
+ 	break;
+ 
            /*--------- Default, unknown command ----------*/
        default:
  	panic("Unexpected command case");
***************
*** 2664,2673 ****
  
   ----*/
  void
! cmd_reply(state, msgmap, agg)
       struct pine *state;
       MSGNO_S     *msgmap;
       int	  agg;
  {
      if(any_messages(msgmap, NULL, "to Reply to")){
  #if	defined(DOS) && !defined(WIN32)
--- 2676,2686 ----
  
   ----*/
  void
! cmd_reply(state, msgmap, agg, flags)
       struct pine *state;
       MSGNO_S     *msgmap;
       int	  agg;
+      int	  flags;
  {
      if(any_messages(msgmap, NULL, "to Reply to")){
  #if	defined(DOS) && !defined(WIN32)
***************
*** 2676,2682 ****
  	if(agg && !pseudo_selected(msgmap))
  	  return;
  
! 	reply(state, NULL);
  
  	if(agg)
  	  restore_selected(msgmap);
--- 2689,2695 ----
  	if(agg && !pseudo_selected(msgmap))
  	  return;
  
! 	reply(state, NULL, flags);
  
  	if(agg)
  	  restore_selected(msgmap);
***************
*** 2972,2978 ****
  		break;
  
  	      case 'r':
! 		reply(state, role);
  		break;
  
  	      case 'f':
--- 2985,2991 ----
  		break;
  
  	      case 'r':
! 		reply(state, role, 0);
  		break;
  
  	      case 'f':
***************
*** 8172,8177 ****
--- 8185,8191 ----
            temp[MAILTMPLEN+1], buff1[MAX_SCREEN_COLS+1], *moved_msg = NULL,
  	  buff2[MAX_SCREEN_COLS+1], *folder;
      CONTEXT_S *context;
+     FOLDER_S  *f;
      struct variable *vars = ps_global->vars;
      int ret, expunge = FALSE, no_close = 0;
      char ing[4];
***************
*** 8188,8194 ****
      }
  
      if(stream != NULL){
! 	context = sp_context(stream);
  	folder  = STREAMNAME(stream);
  
          dprint(2, (debugfile, "expunge_and_close: \"%s\"%s\n",
--- 8202,8208 ----
      }
  
      if(stream != NULL){
! 	context = ps_global->context_current;
  	folder  = STREAMNAME(stream);
  
          dprint(2, (debugfile, "expunge_and_close: \"%s\"%s\n",
***************
*** 8201,8206 ****
--- 8215,8226 ----
  	buff1[0] = '\0';
  	buff2[0] = '\0';
  
+ 	if(F_OFF(F_ENABLE_FAST_RECENT,ps_global) && 
+ 	   (f = incoming_folder_data(stream, context))){ 
+ 	   new_mail_in_open_stream(stream, &(f->recent), &(f->messages));
+ 	   f->notified   = 0;
+ 	}
+ 
          if(!stream->rdonly){
  
  	    if(!no_close){
***************
*** 11244,11249 ****
--- 11264,11276 ----
  	    sel_opts3[i++].label = "Bounce";
  	}
  
+ 	if(F_ON(F_SEPARATE_REPLY_ALL,state)){ /* reply all? */
+ 	    sel_opts3[i].ch      = '=';
+ 	    sel_opts3[i].rval    = '=';
+ 	    sel_opts3[i].name    = "=";
+ 	    sel_opts3[i++].label = "Reply All";
+ 	}
+ 
  	if(flags & AC_FROM_THREAD){
  	    if(flags & (AC_COLL | AC_EXPN)){
  		sel_opts3[i].ch      = '/';
***************
*** 11298,11304 ****
  	break;
  
        case 'r' :			/* reply */
! 	cmd_reply(state, msgmap, agg);
  	break;
  
        case 'f' :			/* Forward */
--- 11325,11336 ----
  	break;
  
        case 'r' :			/* reply */
! 	cmd_reply(state, msgmap, agg, (F_ON(F_SEPARATE_REPLY_ALL, ps_global)) ?
! 	                               RSF_NONE : RSF_QUERY_REPLY_ALL);
! 	break;
! 
!       case '=' :			/* reply all */
! 	cmd_reply(state, msgmap, agg, RSF_FORCE_REPLY_ALL);
  	break;
  
        case 'f' :			/* Forward */
Only in pine4.61-cumulative/pine: mailcmd.c.orig
diff -rc pine4.61/pine/mailindx.c pine4.61-cumulative/pine/mailindx.c
*** pine4.61/pine/mailindx.c	2004-06-14 14:59:15.000000000 -0700
--- pine4.61-cumulative/pine/mailindx.c	2005-02-22 14:04:27.000000000 -0800
***************
*** 112,120 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
! 	NULL_MENU,
  	NULL_MENU};
  INST_KEY_MENU(index_keymenu, index_keys);
  #define BACK_KEY 2
--- 112,120 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	{"^H","ChkIncFl",{MC_FORCECHECK,1,{ctrl('H')}},KS_NONE},
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
! 	REPLY_ALL_MENU,
  	NULL_MENU};
  INST_KEY_MENU(index_keymenu, index_keys);
  #define BACK_KEY 2
***************
*** 131,136 ****
--- 131,137 ----
  #define SELCUR_KEY 38
  #define ZOOM_KEY 39
  #define COLLAPSE_KEY 45
+ #define REPLY_ALL_KEY 44	/* used for thread_keymenu, too */
  
  static struct key simple_index_keys[] = 
         {HELP_MENU,
***************
*** 197,203 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
--- 198,204 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	REPLY_ALL_MENU,
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
***************
*** 535,540 ****
--- 536,543 ----
  		km->keys[EXCLUDE_KEY].label = "eXpunge";
  		KS_OSDATASET(&km->keys[EXCLUDE_KEY], KS_EXPUNGE);
  	    }
+ 	    if(F_OFF(F_SEPARATE_REPLY_ALL,ps_global))
+ 	      clrbitn(REPLY_ALL_KEY, bitmap);
  	}
  
  	if(km != &simple_index_keymenu && !THRD_COLLAPSE_ENABLE())
***************
*** 592,597 ****
--- 595,601 ----
  	return;
      }
  
+     state->redrawer    = redraw_index_body;
      state->prev_screen = mail_index_screen;
      state->next_screen = SCREEN_FUN_NULL;
  
***************
*** 702,720 ****
       MAILSTREAM  *stream;
       MSGNO_S     *msgmap;
  {
!     int		 ch, cmd, which_keys, force,
  		 cur_row, cur_col, km_popped, paint_status;
      int          old_day = -1;
!     long	 i, j, k, old_max_msgno;
      IndexType    style, old_style = MsgIndex;
      struct index_state id;
      struct key_menu *km = NULL;
  #if defined(DOS) || defined(OS2)
      extern void (*while_waiting)();
  #endif
  
      dprint(1, (debugfile, "\n\n ---- INDEX MANAGER ----\n"));
!     
      ch                    = 'x';	/* For displaying msg 1st time thru */
      force                 = 0;
      km_popped             = 0;
--- 706,744 ----
       MAILSTREAM  *stream;
       MSGNO_S     *msgmap;
  {
!     int		 ch, cmd, which_keys, force, skip = 0,
  		 cur_row, cur_col, km_popped, paint_status;
      int          old_day = -1;
!     long	 i, j, k, old_max_msgno, nm;
      IndexType    style, old_style = MsgIndex;
      struct index_state id;
      struct key_menu *km = NULL;
+     char	*begin_string, *this_folder = folder_in_list(folder);
+     FOLDER_S *f;
  #if defined(DOS) || defined(OS2)
      extern void (*while_waiting)();
  #endif
  
      dprint(1, (debugfile, "\n\n ---- INDEX MANAGER ----\n"));
!     if ((f = incoming_folder_data(stream, cntxt)) && !f->user_selected){
! 	f->selected = 0;     /* unselect this folder now		     */
! 	f->notified = 1;     /* do not repaint due to changes in this folder */
!     }
!     if (f){
! 	f->origrecent  = stream->recent; /* more accurate than  f->recent */
! 	f->countrecent = 0;
!     }
!     if (cntxt && cntxt->use & CNTXT_INCMNG && state->last_message && 
! 	 (begin_string = strstr(state->last_message,this_folder))){
! 	int index = 0, length_folder = strlen(this_folder);
! 
! 	while (begin_string[index + length_folder] != '\0'){
! 	   begin_string[index] = begin_string[index + length_folder];
! 	   index++;
! 	}
! 	begin_string[index] = '\0';
! 	fs_give((void **)&this_folder);
!     }    
      ch                    = 'x';	/* For displaying msg 1st time thru */
      force                 = 0;
      km_popped             = 0;
***************
*** 749,757 ****
  	}
  
  	/*------- Check for new mail -------*/
!         new_mail(force, NM_TIMING(ch), NM_STATUS_MSG);
! 	force = 0;			/* may not need to next time around */
! 
  	/*
  	 * If the width of the message number field in the display changes
  	 * we need to flush the cache and redraw. When the cache is cleared
--- 773,795 ----
  	}
  
  	/*------- Check for new mail -------*/
!         nm = new_mail(force, NM_TIMING(ch), NM_STATUS_MSG);
! 	if (!skip || nm >= 0L){
! 	   state->in_indx = 1;
! 	   if (nm >= 0L)
! 	      state->force_check_now = 1;
! 	   new_mail_incfolder(state, MC_IFAUTOCHECK);
! 	}
! 	if (f){
! 	   long rec, tot;
! 	   new_mail_in_open_stream(stream, &rec, &tot);
! 	   f->countrecent = rec > f->recent ? rec - f->countrecent : 0;
! 	   f->recent   = rec;
! 	   f->messages = tot;
! 	   f->selected = f->user_selected ? 1 : 0;
! 	}
! 	ps_global->refresh_list = 0;	/* reset refresh_list	    */
! 	force = skip = 0;		/* may not need to next time around */
  	/*
  	 * If the width of the message number field in the display changes
  	 * we need to flush the cache and redraw. When the cache is cleared
***************
*** 946,951 ****
--- 984,992 ----
  	      break;
  	  }
  
+ 	if ((cmd != MC_NONE) && (cmd != MC_FORCECHECK))
+            state->force_check_now = 0;
+ 
  	/*----------- Execute the command ------------------*/
  	switch(cmd){
  
***************
*** 1405,1411 ****
  	    }
  	    /* else fall thru to normal default */
  
! 
              /*---------- Default -- all other command ----------*/
            default:
     do_the_default:
--- 1446,1455 ----
  	    }
  	    /* else fall thru to normal default */
  
!           case MC_TAB:
! 		skip++;
!         /* do not check for new mail in inc fldrs and fall through */ 
!             
              /*---------- Default -- all other command ----------*/
            default:
     do_the_default:
diff -rc pine4.61/pine/mailpart.c pine4.61-cumulative/pine/mailpart.c
*** pine4.61/pine/mailpart.c	2004-07-13 18:35:16.000000000 -0700
--- pine4.61-cumulative/pine/mailpart.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 171,177 ****
  	{"%", "Print", MC_PRINTMSG,1,{'%'}, KS_PRINT},
  	INDEX_MENU,
  	REPLY_MENU,
! 	FORWARD_MENU};
  INST_KEY_MENU(att_index_keymenu, att_index_keys);
  #define	ATT_PARENT_KEY	 2
  #define	ATT_EXPORT_KEY	11
--- 171,190 ----
  	{"%", "Print", MC_PRINTMSG,1,{'%'}, KS_PRINT},
  	INDEX_MENU,
  	REPLY_MENU,
! 	FORWARD_MENU,
! 
! 	HELP_MENU,
! 	OTHER_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	REPLY_ALL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU};
  INST_KEY_MENU(att_index_keymenu, att_index_keys);
  #define	ATT_PARENT_KEY	 2
  #define	ATT_EXPORT_KEY	11
***************
*** 180,185 ****
--- 193,199 ----
  #define	ATT_PRINT_KEY	20
  #define	ATT_REPLY_KEY	22
  #define	ATT_FORWARD_KEY	23
+ #define	ATT_REPLY_ALL_KEY 32
  
  
  static struct key att_view_keys[] =
***************
*** 206,212 ****
  	NULL_MENU,
  	WHEREIS_MENU,
  	{"%", "Print", MC_PRINTMSG,1,{'%'}, KS_PRINT},
! 	NULL_MENU,
  	REPLY_MENU,
  	FORWARD_MENU};
  INST_KEY_MENU(att_view_keymenu, att_view_keys);
--- 220,226 ----
  	NULL_MENU,
  	WHEREIS_MENU,
  	{"%", "Print", MC_PRINTMSG,1,{'%'}, KS_PRINT},
! 	REPLY_ALL_MENU,
  	REPLY_MENU,
  	FORWARD_MENU};
  INST_KEY_MENU(att_view_keymenu, att_view_keys);
***************
*** 218,223 ****
--- 232,238 ----
  #define	ATV_PIPE_KEY	16
  #define	ATV_BOUNCE_KEY	17
  #define	ATV_PRINT_KEY	20
+ #define	ATV_REPLY_ALL_KEY 21
  #define	ATV_REPLY_KEY	22
  #define	ATV_FORWARD_KEY	23
  
***************
*** 248,254 ****
  void	    display_digest_att PROTO((long, ATTACH_S *, int));
  void	    forward_attachment PROTO((MAILSTREAM *, long, ATTACH_S *));
  void	    forward_msg_att PROTO((MAILSTREAM *, long, ATTACH_S *));
! void	    reply_msg_att PROTO((MAILSTREAM *, long, ATTACH_S *));
  void	    bounce_msg_att PROTO((MAILSTREAM *, long, char *, char *));
  int	    scroll_attachment PROTO((char *, STORE_S *, SourceType,
  				     HANDLE_S *, ATTACH_S *, int));
--- 263,269 ----
  void	    display_digest_att PROTO((long, ATTACH_S *, int));
  void	    forward_attachment PROTO((MAILSTREAM *, long, ATTACH_S *));
  void	    forward_msg_att PROTO((MAILSTREAM *, long, ATTACH_S *));
! void	    reply_msg_att PROTO((MAILSTREAM *, long, ATTACH_S *, int));
  void	    bounce_msg_att PROTO((MAILSTREAM *, long, char *, char *));
  int	    scroll_attachment PROTO((char *, STORE_S *, SourceType,
  				     HANDLE_S *, ATTACH_S *, int));
***************
*** 537,542 ****
--- 552,559 ----
  	       || MIME_DGST(last_type, last_subtype)){
  		if(F_OFF(F_ENABLE_BOUNCE, ps))
  		  clrbitn(ATT_BOUNCE_KEY, bitmap);
+ 		if(F_OFF(F_SEPARATE_REPLY_ALL, ps))
+ 		  clrbitn(ATT_REPLY_ALL_KEY, bitmap);
  
  		km->keys[ATT_EXPORT_KEY].name  = "";
  		km->keys[ATT_EXPORT_KEY].label = "";
***************
*** 544,549 ****
--- 561,567 ----
  	    else{
  		clrbitn(ATT_BOUNCE_KEY, bitmap);
  		clrbitn(ATT_REPLY_KEY, bitmap);
+ 		clrbitn(ATT_REPLY_ALL_KEY, bitmap);
  
  		if(last_type != TYPETEXT)
  		  clrbitn(ATT_PRINT_KEY, bitmap);
***************
*** 907,913 ****
  	    break;
  
  	  case MC_REPLY :
! 	    reply_msg_att(ps->mail_stream, msgno, current->attp);
  	    break;
  
  	  case MC_FORWARD :
--- 925,938 ----
  	    break;
  
  	  case MC_REPLY :
! 	    reply_msg_att(ps->mail_stream, msgno, current->attp,
! 	                  (F_ON(F_SEPARATE_REPLY_ALL, ps_global)) ?
! 	                   RSF_NONE : RSF_QUERY_REPLY_ALL);
! 	    break;
! 
! 	  case MC_REPLY_ALL :
! 	    reply_msg_att(ps->mail_stream, msgno, current->attp,
! 	                  RSF_FORCE_REPLY_ALL);
  	    break;
  
  	  case MC_FORWARD :
***************
*** 2689,2698 ****
--- 2714,2726 ----
      if(MIME_MSG_A(a) || MIME_DGST_A(a)){
  	if(F_OFF(F_ENABLE_BOUNCE, ps_global))
  	  clrbitn(ATV_BOUNCE_KEY, sargs.keys.bitmap);
+ 	if(F_OFF(F_SEPARATE_REPLY_ALL, ps_global))
+ 	  clrbitn(ATV_REPLY_ALL_KEY, sargs.keys.bitmap);
      }
      else{
  	clrbitn(ATV_BOUNCE_KEY, sargs.keys.bitmap);
  	clrbitn(ATV_REPLY_KEY, sargs.keys.bitmap);
+ 	clrbitn(ATV_REPLY_ALL_KEY, sargs.keys.bitmap);
  	clrbitn(ATV_EXPORT_KEY, sargs.keys.bitmap);
      }
  
***************
*** 2735,2741 ****
  	break;
  
        case MC_REPLY :
! 	reply_msg_att(ps_global->mail_stream, rawno, sparms->proc.data.p);
  	break;
  
        case MC_FORWARD :
--- 2763,2776 ----
  	break;
  
        case MC_REPLY :
! 	reply_msg_att(ps_global->mail_stream, rawno, sparms->proc.data.p,
! 	              (F_ON(F_SEPARATE_REPLY_ALL, ps_global)) ?
! 	              RSF_NONE : RSF_QUERY_REPLY_ALL);
! 	break;
! 
!       case MC_REPLY_ALL :
! 	reply_msg_att(ps_global->mail_stream, rawno, sparms->proc.data.p,
! 	              RSF_FORCE_REPLY_ALL);
  	break;
  
        case MC_FORWARD :
***************
*** 3220,3226 ****
  
  	    if(fetch_contents(stream, msgno, a->number,
  			      &body->nested.part->next->body)){
! 		pine_send(outgoing, &body, "FORWARD MESSAGE",
  			  role, NULL, NULL, redraft_pos, NULL, NULL, FALSE);
  
  		ps_global->mangled_screen = 1;
--- 3255,3261 ----
  
  	    if(fetch_contents(stream, msgno, a->number,
  			      &body->nested.part->next->body)){
! 		pine_send(NULL, outgoing, &body, "FORWARD MESSAGE",
  			  role, NULL, NULL, redraft_pos, NULL, NULL, FALSE);
  
  		ps_global->mangled_screen = 1;
***************
*** 3391,3397 ****
  	    fs_give((void **) &p);
  
  	    if(body){
! 		pine_send(outgoing, &body,
  			  "FORWARD MESSAGE",
  			  role, NULL,
  			  reply.flags ? &reply : NULL,
--- 3426,3432 ----
  	    fs_give((void **) &p);
  
  	    if(body){
! 		pine_send(NULL, outgoing, &body,
  			  "FORWARD MESSAGE",
  			  role, NULL,
  			  reply.flags ? &reply : NULL,
***************
*** 3434,3450 ****
  
   ----*/
  void
! reply_msg_att(stream, msgno, a)
      MAILSTREAM *stream;
      long	msgno;
      ATTACH_S   *a;
  {
      ADDRESS       *saved_from, *saved_to, *saved_cc, *saved_resent;
      ENVELOPE      *outgoing;
      BODY          *body;
      void          *msgtext;
      char          *tp, *prefix = NULL;
!     int            include_text = 0, flags = RSF_QUERY_REPLY_ALL;
      long           rflags;
      PAT_STATE      dummy;
      REDRAFT_POS_S *redraft_pos = NULL;
--- 3469,3486 ----
  
   ----*/
  void
! reply_msg_att(stream, msgno, a, flags)
      MAILSTREAM *stream;
      long	msgno;
      ATTACH_S   *a;
+     int flags;
  {
      ADDRESS       *saved_from, *saved_to, *saved_cc, *saved_resent;
      ENVELOPE      *outgoing;
      BODY          *body;
      void          *msgtext;
      char          *tp, *prefix = NULL;
!     int            include_text = 0;
      long           rflags;
      PAT_STATE      dummy;
      REDRAFT_POS_S *redraft_pos = NULL;
***************
*** 3556,3562 ****
  				 msgtext, prefix, include_text, role,
  				 1, &redraft_pos)){
  		/* partially formatted outgoing message */
! 		pine_send(outgoing, &body, "COMPOSE MESSAGE REPLY",
  			  role, fcc.tptr, &reply, redraft_pos, NULL, NULL, 0);
  
  		pine_free_body(&body);
--- 3592,3598 ----
  				 msgtext, prefix, include_text, role,
  				 1, &redraft_pos)){
  		/* partially formatted outgoing message */
! 		pine_send(NULL, outgoing, &body, "COMPOSE MESSAGE REPLY",
  			  role, fcc.tptr, &reply, redraft_pos, NULL, NULL, 0);
  
  		pine_free_body(&body);
diff -rc pine4.61/pine/mailview.c pine4.61-cumulative/pine/mailview.c
*** pine4.61/pine/mailview.c	2004-07-14 17:25:10.000000000 -0700
--- pine4.61-cumulative/pine/mailview.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 235,244 ****
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
  	RCOMPOSE_MENU,
  	NULL_MENU,
  	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU};
--- 235,244 ----
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
  	RCOMPOSE_MENU,
+ 	{"^H","ChkIncFl",{MC_FORCECHECK,1,{ctrl('H')}},KS_NONE},	
  	NULL_MENU,
  	NULL_MENU,
! 	REPLY_ALL_MENU,
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU};
***************
*** 252,257 ****
--- 252,258 ----
  #define BOUNCE_KEY		33
  #define FLAG_KEY		34
  #define VIEW_PIPE_KEY		35
+ #define REPLY_ALL_KEY		44
  
  static struct key simple_text_keys[] =
         {HELP_MENU,
***************
*** 585,590 ****
--- 586,594 ----
  	if(F_OFF(F_ENABLE_FULL_HDR, ps_global))
  	  clrbitn(VIEW_FULL_HEADERS_KEY, scrollargs.keys.bitmap);
  
+ 	if (F_OFF(F_SEPARATE_REPLY_ALL, ps_global))
+ 	  clrbitn(REPLY_ALL_KEY, scrollargs.keys.bitmap);
+ 
  	if(!handles){
  	    /*
  	     * NOTE: the comment below only really makes sense if we
***************
*** 4968,4974 ****
  	if(!(role && role->fcc))
  	  fcc = get_fcc_based_on_to(outgoing->to);
  
! 	pine_send(outgoing, &body, "\"MAILTO\" COMPOSE",
  		  role, fcc, &fake_reply, redraft_pos, NULL, NULL, 0);
  	rv++;
  	ps_global->mangled_screen = 1;
--- 4972,4978 ----
  	if(!(role && role->fcc))
  	  fcc = get_fcc_based_on_to(outgoing->to);
  
! 	pine_send(NULL, outgoing, &body, "\"MAILTO\" COMPOSE",
  		  role, fcc, &fake_reply, redraft_pos, NULL, NULL, 0);
  	rv++;
  	ps_global->mangled_screen = 1;
***************
*** 5581,5587 ****
         && !strucmp(att->body->subtype, "plain")
         && (parmval = rfc2231_get_param(att->body->parameter,
  				       "format", NULL, NULL))){
! 	if(!strucmp(parmval, "flowed"))
  	  is_flowed_msg = 1;
  	fs_give((void **) &parmval);
      }
--- 5585,5592 ----
         && !strucmp(att->body->subtype, "plain")
         && (parmval = rfc2231_get_param(att->body->parameter,
  				       "format", NULL, NULL))){
! 	if(!strucmp(parmval, "flowed") &&
! 	   F_OFF(F_QUELL_DISPLAYING_FLOWED_TEXT, ps_global))
  	  is_flowed_msg = 1;
  	fs_give((void **) &parmval);
      }
***************
*** 7021,7027 ****
  {
      register long    cur_top_line,  num_display_lines;
      int              result, done, ch, cmd, found_on, found_on_col,
! 		     first_view, force, scroll_lines, km_size,
  		     cursor_row, cursor_col, km_popped;
      long             jn;
      struct key_menu *km;
--- 7026,7032 ----
  {
      register long    cur_top_line,  num_display_lines;
      int              result, done, ch, cmd, found_on, found_on_col,
! 		     first_view, force, scroll_lines, km_size, skip = 0,
  		     cursor_row, cursor_col, km_popped;
      long             jn;
      struct key_menu *km;
***************
*** 7230,7235 ****
--- 7235,7242 ----
  	/*============ Check for New Mail and CheckPoint ============*/
          if(!sparms->quell_newmail &&
  	   new_mail(force, NM_TIMING(ch), NM_STATUS_MSG) >= 0){
+ 	    skip = 0;
+ 	    ps_global->force_check_now = 1;
  	    update_scroll_titlebar(cur_top_line, 1);
  	    if(ps_global->mangled_footer)
                draw_keymenu(km, bitmap, ps_global->ttyo->screen_cols,
***************
*** 7237,7242 ****
--- 7244,7263 ----
  
  	    ps_global->mangled_footer = 0;
  	}
+ 	ps_global->in_pico = 0;
+ 
+ 	if (!skip){
+ 	    ps_global->in_indx = !ps_global->in_fld_list;
+ 	    new_mail_incfolder(ps_global,MC_IFAUTOCHECK);
+ 	}
+ 	skip = 0;
+ 	if (ps_global->refresh_list > 0){
+ 	   ps_global->refresh_list = 0;
+ 	   if (ps_global->in_fld_list){
+ 	      cmd = MC_RESIZE;
+ 	      goto end;
+ 	   }
+ 	}
  
  	/*
  	 * If an expunge of the current message happened during the
***************
*** 7371,7376 ****
--- 7392,7398 ----
  	      break;
  	  }
  
+         ps_global->force_check_now = (((cmd == MC_NONE) || (cmd == MC_FORCECHECK)) ? 1 : 0);
  
  	/*============= Execute command =======================*/
  	switch(cmd){
***************
*** 8114,8120 ****
--- 8136,8158 ----
  
              break;
  
+                 /*------- Check incoming folders -------*/
+            case MC_FORCECHECK:
+ 	      ps_global->force_check_now = 1;
+ 	      if (new_mail_incfolder(ps_global,MC_FORCECHECK) && 
+ 		   ps_global->refresh_list > 0){
+ 		ps_global->refresh_list = 0;
+ 		if (ps_global->in_fld_list){
+ 		   cmd = MC_RESIZE;
+ 		   goto end;
+ 		}
+ 	      }
+ 	     break;
  
+            case MC_TAB:
+ 		skip++;
+         /* do not check for new mail in inc fldrs and fall through */ 
+             
  	    /*------- Standard commands ------*/
            default:
  	    whereis_pos.row = 0;
***************
*** 8186,8191 ****
--- 8224,8230 ----
  
      } /* End of while() -- loop executing commands */
  
+ end:
      ps_global->redrawer	= NULL;	/* next statement makes this invalid! */
      zero_scroll_text();		/* very important to zero out on return!!! */
      scroll_state(SS_FREE);
Only in pine4.61-cumulative/pine: mailview.c.orig
diff -rc pine4.61/pine/newmail.c pine4.61-cumulative/pine/newmail.c
*** pine4.61/pine/newmail.c	2004-07-14 11:17:12.000000000 -0700
--- pine4.61-cumulative/pine/newmail.c	2005-02-22 14:01:51.000000000 -0800
***************
*** 48,53 ****
--- 48,55 ----
  
  #include "headers.h"
  
+ static long incoming_folders_new_mail  = 0L;
+ 
  
  /*
   * Internal prototypes
***************
*** 682,687 ****
--- 684,690 ----
  				"subject:"
      };
  
+     ps_global->refresh_list += 1;	/* Force update in folder screen */
      if(stream)
        e = pine_mail_fetchstructure(stream, max_num, NULL);
  
***************
*** 1056,1061 ****
--- 1059,1069 ----
  	if(m && sp_flagged(m, SP_LOCKED))
  	  sp_set_mail_since_cmd(m, 0L);
      }
+ 
+     if (incoming_folders_new_mail > 0L){
+ 	icon_text(NULL, IT_NEWMAIL);
+ 	incoming_folders_new_mail = 0L;
+     }
  }
  
  
***************
*** 1124,1126 ****
--- 1132,1480 ----
  
      return(rv);
  }
+ 
+ /*  Check for new mail in incoming folders */
+ 
+ int 
+ new_mail_incfolder(state,command)
+    struct pine *state;
+    int command;
+ {
+  char **listflds = NULL, **listnflds= NULL;
+  char *fldslctd  = NULL, *message   = NULL, *message2  = NULL;
+  int  *selfld    = NULL;
+  int   index = 0, i, nflds = 0, tflds, tlflds = 0, newflds = 0, save_state;
+  static time_t now, old = 0;
+  static int check_started = 0;
+  int  tcp_query_timeout = state->tcp_query_timeout;
+  int  tcp_open_timeout = 30;
+  int  long_report = F_OFF(F_ENABLE_FAST_RECENT, state);
+  FOLDER_S *inc_fld;
+  char  mailbox_name[MAXPATH+1];
+ 
+    if (F_OFF(F_ENABLE_INCOMING,ps_global) 
+ 	|| F_OFF(F_ENABLE_INCOMING_CHECK,ps_global)
+ 	|| (state->inc_check_rule == IC_MAN
+ 		&& command != MC_FORCECHECK)
+ 	|| (state->inc_check_rule == IC_MAN_AUTO
+ 		&& check_started == 0 && command != MC_FORCECHECK))
+       return -1;
+ 
+    if ((!state->force_check_now) || (state->checking_incfld)){
+        state->force_check_now = 1;      /* I'll be back, but wait a moment */
+         return -1;
+    }
+ 
+    now = time(0);
+    if ((old != 0) && (command != MC_FORCECHECK) && 
+       (state->refresh_list == 0) &&
+       (now - old < timeo*state->delay))
+ 	return -1;
+ 
+    state->checking_incfld = 1;		/* point of no return */
+    check_started = 1;			/* checks have already started */
+    ps_global->mm_log_error = 0;		/* turn off display of errors */
+    ps_global->noshow_error = 1;
+ 
+    if(state->VAR_TCPOPENTIMEO)
+       (void)SVAR_TCP_OPEN(state, tcp_open_timeout, tmp_20k_buf);
+    mail_parameters(NULL, SET_OPENTIMEOUT, (void *)(long)state->incfld_timeout);
+ 
+    save_state = ps_global->in_init_seq;
+    state->in_init_seq = 0;  /* force output of cue during check */
+    check_cue_display("+");      /* Show something to indicate delay */
+    MoveCursor(state->ttyo->screen_rows -FOOTER_ROWS(state),0);
+    fflush(stdout);
+    state->tcp_query_timeout = state->incfld_timeout;
+ 
+    if(state->context_current){
+      char	*nxtfld = NULL;
+      MAILSTREAM *nxtstrm = NULL;
+      long        rec, tot;
+      int	 opstrm;
+      CONTEXT_S  *ctxt = sp_context(sp_inbox_stream());
+ 
+     /* Look for the Incoming folder collections, Normally the incoming folders
+      * collection is the first collection, but just to be sure, we back up to
+      * the beginning and go forward from there to try to find it.
+      */
+ 
+      if (!ctxt){
+ 	ctxt =  state->context_current;
+ 	while (1){
+ 	  if (ctxt->prev)
+ 	     ctxt = ctxt->prev;
+ 	  else
+ 	     break;
+ 	}
+ 	while (1){
+ 	  if (ctxt->use & CNTXT_INCMNG)
+ 	     break;
+ 	  else
+ 	     ctxt = ctxt->next;
+ 	}
+      }
+ 
+      tflds    = folder_total(FOLDERS(ctxt));
+      listflds = (char **) fs_get((tflds + 2) * sizeof(char *));
+      listnflds= (char **) fs_get((tflds + 2) * sizeof(char *));
+      selfld   = (int   *) fs_get((tflds + 2) * sizeof(int));
+ 
+      memset((void *)(selfld), 0, (tflds + 2) * sizeof(int));
+      memset((void *)(listflds), 0, (tflds + 2) * sizeof(char *));
+      memset((void *)(listnflds), 0, (tflds + 2) * sizeof(int *));
+ 
+      nxtfld = (char *) fs_get((strlen(state->inbox_name) + 1)*sizeof(char));
+      nxtfld = cpystr(state->inbox_name);
+ 
+      for(index = folder_index(nxtfld, ctxt, FI_FOLDER) + long_report ? 0 : 1;
+ 	index >= (long_report ? 0 : 1) && index < tflds
+         && (inc_fld = folder_entry(index, FOLDERS(ctxt)))
+         && !inc_fld->isdir; index++){
+ 
+ 	if (nxtfld)
+ 	   fs_give((void **)&nxtfld);
+ 
+ 	rec = tot = 0L;
+         nxtfld = (char *) fs_get((strlen(FLDR_NAME(inc_fld)) + 1)*sizeof(char));
+         nxtfld = cpystr(FLDR_NAME(inc_fld));
+ 
+ 	fldslctd = next_folder_check(&nxtstrm, ctxt, &rec, &tot, inc_fld,
+ 								 &opstrm);
+ 
+         if ((opstrm && fldslctd 
+ 		&& (rec != inc_fld->origrecent || tot != inc_fld->messages))
+ 	   || (!opstrm && (rec != inc_fld->recent || tot != inc_fld->messages)))
+ 	  state->refresh_list++;
+ 
+         inc_fld->countrecent = rec > inc_fld->origrecent ?
+ 					 rec - inc_fld->origrecent : 0;
+ 	inc_fld->messages = tot;
+ 	inc_fld->recent   = rec;
+ 
+         if (long_report && inc_fld->countrecent == 0L && fldslctd)
+              fs_give((void **)&fldslctd);
+ 
+         if (fldslctd){
+ 	   state->refresh_list += inc_fld->selected ? 0 : 1;
+ 	   inc_fld->selected = 1;
+ 	   inc_fld->notified = 0;	/* reset */
+ 	   if (strcmp(fldslctd, state->inbox_name)){
+ 		listflds[++nflds] = (char *) 
+ 			 fs_get((strlen(fldslctd) + 5) * sizeof(char *));
+ 		listflds[nflds] = cpystr(fldslctd);
+ 		tlflds += strlen(nxtfld) + 4; /* 1 space, 2 quotes, 1 comma */
+ 		selfld[nflds] = index;
+ 	   }
+ 	   fs_give((void **)&fldslctd);
+         }
+ 	else{
+ 	   if (inc_fld->selected)
+ 	     state->refresh_list += inc_fld->user_selected ? 0 : 1;
+ 	   if (folder_in_message_list(FLDR_NAME(inc_fld)))
+ 	     inc_fld->selected    = inc_fld->user_selected ? 1 : 0;
+ 	}
+      }
+      if (nxtfld)
+ 	fs_give((void **)&nxtfld);
+ 
+      if(nxtstrm)
+ 	pine_mail_close(nxtstrm);
+ 
+      state->mm_log_error = 1;	/* turn display of errors back on */
+      state->noshow_error = 0;
+ 
+      if(nflds == 0){
+         if (command == MC_FORCECHECK && state->VAR_INCOMING_FOLDERS_CHECK)
+ 	   q_status_message(SM_ORDER, 0, 2,
+                    "There are NO new messages in your Incoming Folders");
+         if (state->last_message)
+            fs_give((void **)&(state->last_message));
+      }
+      else{  /* nflds > 0 */
+ 	message = (char *) fs_get((tlflds + 30)*sizeof(char));	\
+ 	strcpy(message,"New message in folder");
+ 	if (!state->last_message)
+ 	   state->last_message = cpystr(message);
+ 	strcat(message,(nflds > 1) ? "s " : " ");
+ 	if(nflds > 1){
+            for (i = 1; i <= nflds - 2; i++){
+ 	     strcat(message,"\"");
+              strcat(message,listflds[i]);
+ 	     strcat(message,"\", ");
+              if (!folder_in_message_list(listflds[i])){
+                 listnflds[++newflds] = (char *)
+                          fs_get((strlen(listflds[i]) + 1)*sizeof(char));
+                 listnflds[newflds] = cpystr(listflds[i]);
+              }
+ 	   }
+            strcat(message,"\"");
+            strcat(message,listflds[nflds - 1]);
+            strcat(message,"\" and \"");
+            strcat(message,listflds[nflds]);
+            strcat(message,"\"");
+            if (!folder_in_message_list(listflds[nflds-1])){
+               listnflds[++newflds] = (char *)
+                            fs_get((strlen(listflds[nflds-1]) + 1)*sizeof(char));
+               listnflds[newflds] = cpystr(listflds[nflds-1]);
+            }
+            if (!folder_in_message_list(listflds[nflds])){
+               listnflds[++newflds] = (char *)
+                            fs_get((strlen(listflds[nflds]) + 1)*sizeof(char));
+               listnflds[newflds] = cpystr(listflds[nflds]);
+            }
+ 	} 
+ 	else{
+           strcat(message,"\"");
+           strcat(message,listflds[1]);
+           strcat(message,"\"");
+           if (!folder_in_message_list(listflds[1])){
+             listnflds[++newflds] = (char *)
+                          fs_get((strlen(listflds[1]) + 1) * sizeof(char));
+             listnflds[newflds] = cpystr(listflds[1]);
+           }
+         }
+         if (newflds){
+ 	   state->refresh_list += 1;
+            message2 = (char *) malloc((tlflds + 30)*sizeof(char));
+            strcpy(message2,"New message in folder");
+            strcat(message2,(newflds > 1) ? "s " : " ");
+ 	   if (newflds > 1){
+ 	      for (i = 1; i <= newflds - 2; i++){
+                   strcat(message2,"\"");
+                   strcat(message2,listnflds[i]);
+                   strcat(message2,"\", ");
+ 	      }
+               strcat(message2,"\"");
+               strcat(message2,listnflds[newflds - 1]);
+               strcat(message2,"\" and \"");
+               strcat(message2,listnflds[newflds]);
+               strcat(message2,"\"");
+ 
+ 	   } 
+ 	   else{
+              strcat(message2,"\"");
+              strcat(message2,listnflds[1]);
+              strcat(message2,"\"");
+ 	   }
+         }
+         state->last_message = cpystr(message);
+         /* decide if we are going to use "message" or "message2" */
+         if (newflds && (newflds != nflds) && (command != MC_FORCECHECK)){
+ 	  if (message)
+ 	    fs_give((void **)&message);
+ 	  message = cpystr(message2);
+         }
+         if ((newflds > 0  && 
+ 	    (!folder_in_message_list(state->cur_folder) || !state->in_indx))
+ 	   || (command == MC_FORCECHECK)){
+           if (strlen(message) < state->ttyo->screen_cols - 2){
+              if (command != MC_FORCECHECK){
+                 q_status_message(SM_ASYNC | SM_DING, 0, 60, message);
+                 icon_text(message, IT_NEWMAIL);
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 2, message);
+           }
+           else{
+ 	     message = (char *) fs_get (80 * sizeof(char));
+              message = cpystr("You have NEW messages in your Incoming Folders");
+              if (strlen(message) < state->ttyo->screen_cols - 2){
+                if (command != MC_FORCECHECK){
+                   q_status_message(SM_ASYNC | SM_DING, 0, 60, message);
+                   icon_text(message, IT_NEWMAIL);
+                }
+                else
+                   q_status_message(SM_ORDER, 0, 2, message);
+              }
+           }
+         }
+         if (message)
+ 	   fs_give((void **)&message);
+ 	if (message2)
+ 	   fs_give((void **)&message2);
+      } /* end of nflds > 0 */
+    }
+    state->checking_incfld = 0;
+    check_cue_display(" ");		/* Erase the "+" added before */  
+    state->in_init_seq = save_state;	/* restore original value     */
+    MoveCursor(state->ttyo->screen_rows -FOOTER_ROWS(state),0);
+    incoming_folders_new_mail = nflds;
+ 
+    if (listflds){
+       for (i = 0; i < nflds && listflds[i]; i++);
+ 	fs_give((void **)&listflds[i]);
+       fs_give((void **)listflds);
+     }
+    if (listnflds){
+       for (i = 0; i < newflds && listnflds[i]; i++);
+ 	fs_give((void **)&listnflds[i]);
+       fs_give((void **)listnflds);
+    }
+    if (selfld)
+      fs_give((void **)&selfld);
+    old = time(0);
+    state->delay = time(0) - now + 1;
+    state->tcp_query_timeout = tcp_query_timeout;
+    mail_parameters(NULL, SET_OPENTIMEOUT, (void *)(long)tcp_open_timeout);
+ 
+    return nflds;
+ }
+ 
+ char *
+ folder_in_list(folder)
+ char *folder;
+ {   
+  int length = strlen(folder) + 4;
+  char *result;
+  int i;
+  
+     result = (char *) fs_get((length)*sizeof(char));
+             
+     result[0] = ' '; /* a space */
+     result[1] = '\"'; /* quotes */
+     for (i = 0; i < strlen(folder); i++)
+        result[i+2] = folder[i];   
+     result[length - 2] = '\"';
+     result[length - 1] = '\0';
+  return  result;
+ }
+ 
+ 
+ int
+ folder_in_message_list(folder)
+ char *folder;
+ {
+ int rv = 0;
+ char *folderquoted = folder_in_list(folder);
+ 
+   if (ps_global->last_message && *ps_global->last_message
+         && strstr(ps_global->last_message, folderquoted))
+      rv++;
+   if (folderquoted)
+      fs_give((void **)&folderquoted);
+  return rv;
+ }
+ 
+ char *
+ new_mail_in_open_stream(stream, rec, tot)
+   MAILSTREAM *stream;
+   long *rec;
+   long *tot;
+ {
+    long excluded;
+ 
+    if((excluded = any_lflagged(sp_msgmap(stream), MN_EXLD))){
+       *tot = stream->nmsgs - excluded;
+       if(tot)
+          *rec = count_flagged(stream, F_RECENT);
+       else
+          *rec = 0L;
+    }
+    else{
+       *tot = stream->nmsgs;
+       *rec = stream->recent;
+    }
+ 
+    return *rec ? cpystr(STREAMNAME(stream)) : NULL;
+ }
diff -rc pine4.61/pine/osdep/termin.gen pine4.61-cumulative/pine/osdep/termin.gen
*** pine4.61/pine/osdep/termin.gen	2003-12-03 16:51:08.000000000 -0800
--- pine4.61-cumulative/pine/osdep/termin.gen	2005-02-22 14:01:51.000000000 -0800
***************
*** 1040,1046 ****
      }
  
      if(firsttime) {
! 	firsttime = 0;
  	if(ps_global->in_init_seq) {
  	    ps_global->in_init_seq = 0;
  	    ps_global->save_in_init_seq = 0;
--- 1040,1046 ----
      }
  
      if(firsttime) {
! 	firsttime = ps_global->checking_incfld ? (char) 1 : 0;
  	if(ps_global->in_init_seq) {
  	    ps_global->in_init_seq = 0;
  	    ps_global->save_in_init_seq = 0;
diff -rc pine4.61/pine/other.c pine4.61-cumulative/pine/other.c
*** pine4.61/pine/other.c	2004-07-02 14:38:16.000000000 -0700
--- pine4.61-cumulative/pine/other.c	2005-02-22 14:01:51.000000000 -0800
***************
*** 1581,1586 ****
--- 1581,1587 ----
  	       || vtmp == &ps->vars[V_TCPREADWARNTIMEO]
  	       || vtmp == &ps->vars[V_TCPWRITEWARNTIMEO]
  	       || vtmp == &ps->vars[V_TCPQUERYTIMEO]
+ 	       || vtmp == &ps->vars[V_INCFLDTIMEO]
  	       || vtmp == &ps->vars[V_RSHOPENTIMEO]
  	       || vtmp == &ps->vars[V_SSHOPENTIMEO]
  	       || vtmp == &ps->vars[V_USERINPUTTIMEO]
***************
*** 1706,1711 ****
--- 1707,1713 ----
  	   v == &ps->vars[V_FCC_RULE] ||
  	   v == &ps->vars[V_GOTO_DEFAULT_RULE] ||
  	   v == &ps->vars[V_INCOMING_STARTUP] ||
+ 	   v == &ps->vars[V_INCOMING_RULE] ||
  	   v == &ps->vars[V_PRUNING_RULE] ||
  	   v == &ps->vars[V_REOPEN_RULE] ||
  	   v == &ps->vars[V_THREAD_DISP_STYLE] ||
***************
*** 1735,1740 ****
--- 1737,1744 ----
        rulefunc = goto_rules;
      else if(v == &ps->vars[V_INCOMING_STARTUP])
        rulefunc = incoming_startup_rules;
+     else if(v == &ps->vars[V_INCOMING_RULE])
+       rulefunc = incoming_check_rules;
      else if(v == startup_ptr)
        rulefunc = startup_rules;
      else if(v == &ps->vars[V_PRUNING_RULE])
***************
*** 1909,1914 ****
--- 1913,1919 ----
        case V_TCPREADWARNTIMEO :
        case V_TCPWRITEWARNTIMEO :
        case V_TCPQUERYTIMEO :
+       case V_INCFLDTIMEO :
        case V_RSHCMD :
        case V_RSHPATH :
        case V_RSHOPENTIMEO :
***************
*** 7280,7285 ****
--- 7285,7292 ----
  	return(h_config_nntp_server);
        case V_INBOX_PATH :
  	return(h_config_inbox_path);
+       case V_INCOMING_FOLDERS_CHECK :
+         return(h_config_check_inc_fld);
        case V_PRUNED_FOLDERS :
  	return(h_config_pruned_folders);
        case V_DEFAULT_FCC :
***************
*** 7364,7369 ****
--- 7371,7378 ----
  	return(h_config_tcp_writewarn_timeo);
        case V_TCPQUERYTIMEO :
  	return(h_config_tcp_query_timeo);
+       case V_INCFLDTIMEO :
+ 	return(h_config_inc_fld_timeo);
        case V_RSHOPENTIMEO :
  	return(h_config_rsh_open_timeo);
        case V_SSHOPENTIMEO :
***************
*** 7444,7449 ****
--- 7453,7460 ----
  	return(h_config_goto_default);
        case V_INCOMING_STARTUP:
  	return(h_config_inc_startup);
+       case V_INCOMING_RULE:
+ 	return(h_config_inc_rule);
        case V_PRUNING_RULE:
  	return(h_config_pruning_rule);
        case V_REOPEN_RULE:
***************
*** 7875,7880 ****
--- 7886,7895 ----
  	    lowrange = 5;
  	    hirange  = 1000;
  	}
+ 	else if((*cl)->var == &ps->vars[V_INCFLDTIMEO]){
+ 	    lowrange = 2;
+ 	    hirange  = 60;
+ 	}
  	else if((*cl)->var == &ps->vars[V_TCPWRITEWARNTIMEO] ||
  	        (*cl)->var == &ps->vars[V_RSHOPENTIMEO] ||
  	        (*cl)->var == &ps->vars[V_SSHOPENTIMEO] ||
***************
*** 12606,12611 ****
--- 12621,12632 ----
  	  if(ps->VAR_TCPQUERYTIMEO && SVAR_TCP_QUERY(ps, val, tmp_20k_buf))
  	    q_status_message(SM_ORDER, 3, 5, tmp_20k_buf);
      }
+     else if(var == &ps->vars[V_INCFLDTIMEO]){
+ 	val = 5;
+ 	if(!revert)
+ 	  if(ps->VAR_INCFLDTIMEO && SVAR_TCP_QUERY(ps, val, tmp_20k_buf))
+ 	    q_status_message(SM_ORDER, 3, 5, tmp_20k_buf);
+     }
      else if(var == &ps->vars[V_RSHOPENTIMEO]){
  	val = 15;
  	if(!revert)
***************
*** 12655,12660 ****
--- 12676,12686 ----
  	}
      }
  #endif
+     else if(var == &ps->vars[V_INCOMING_FOLDERS_CHECK] && 
+ 	    F_OFF(F_ENABLE_FAST_RECENT, ps)){
+ 	ps->force_check_now = 1;
+ 	new_mail_incfolder(ps, MC_FORCECHECK);	/* yes, update it now */
+     }
      else if(var == &ps->vars[V_MAILCHECK]){
  	timeo = 15;
  	if(SVAR_MAILCHK(ps, timeo, tmp_20k_buf)){
diff -rc pine4.61/pine/pine.c pine4.61-cumulative/pine/pine.c
*** pine4.61/pine/pine.c	2004-07-14 11:17:13.000000000 -0700
--- pine4.61-cumulative/pine/pine.c	2005-02-22 14:01:51.000000000 -0800
***************
*** 263,268 ****
--- 263,270 ----
      ps_global->sort_types[8]   = SortScore;
      ps_global->sort_types[9]   = SortThread;
      ps_global->sort_types[10]   = EndofList;
+     ps_global->force_check_now = 1;
+     ps_global->delay	       = 1;
      ps_global->atmts           = (ATTACH_S *) fs_get(sizeof(ATTACH_S));
      ps_global->atmts_allocated = 1;
      ps_global->atmts->description = NULL;
***************
*** 371,376 ****
--- 373,379 ----
      mail_parameters(NULL, SET_TIMEOUT, (void *) pine_tcptimeout);
      /* could be TO_BAIL_THRESHOLD, 15 seems more appropriate for now */
      pine_state->tcp_query_timeout = 15;
+     pine_state->incfld_timeout	  =  5;
  
      mail_parameters(NULL, SET_SENDCOMMAND, (void *) pine_imap_cmd_happened);
      mail_parameters(NULL, SET_FREESTREAMSPAREP, (void *) sp_free_callback);
***************
*** 3121,3127 ****
  {
      int quit = 0;
  
!     dprint(1, (debugfile, "\n\n    ---- QUIT SCREEN ----\n"));    
  
      if(F_ON(F_CHECK_MAIL_ONQUIT,ps_global)
         && new_mail(1, VeryBadTime, NM_STATUS_MSG | NM_DEFER_SORT) > 0
--- 3124,3131 ----
  {
      int quit = 0;
  
!     dprint(1, (debugfile, "\n\n    ---- QUIT SCREEN ----\n"));
!     ps_global->in_pico = 1; /* we are leaving anyway */
  
      if(F_ON(F_CHECK_MAIL_ONQUIT,ps_global)
         && new_mail(1, VeryBadTime, NM_STATUS_MSG | NM_DEFER_SORT) > 0
diff -rc pine4.61/pine/pine.h pine4.61-cumulative/pine/pine.h
*** pine4.61/pine/pine.h	2004-07-14 17:25:12.000000000 -0700
--- pine4.61-cumulative/pine/pine.h	2005-02-22 14:02:00.000000000 -0800
***************
*** 229,234 ****
--- 229,237 ----
  #ifndef DF_INCOMING_STARTUP
  #define DF_INCOMING_STARTUP	"first-unseen"
  #endif
+ #ifndef DF_INCOMING_RULE
+ #define DF_INCOMING_RULE	"automatic"
+ #endif
  #ifndef DF_PRUNING_RULE
  #define DF_PRUNING_RULE		"ask-ask"
  #endif
***************
*** 596,601 ****
--- 599,605 ----
  		, V_SMTP_SERVER
  		, V_NNTP_SERVER
  		, V_INBOX_PATH
+              	, V_INCOMING_FOLDERS_CHECK
  		, V_ARCHIVED_FOLDERS
  		, V_PRUNED_FOLDERS
  		, V_DEFAULT_FCC
***************
*** 620,625 ****
--- 624,630 ----
  		, V_FLD_SORT_RULE
  		, V_GOTO_DEFAULT_RULE
  		, V_INCOMING_STARTUP
+ 		, V_INCOMING_RULE
  		, V_PRUNING_RULE
  		, V_REOPEN_RULE
  		, V_THREAD_DISP_STYLE
***************
*** 694,699 ****
--- 699,705 ----
  		, V_TCPREADWARNTIMEO
  		, V_TCPWRITEWARNTIMEO
  		, V_TCPQUERYTIMEO
+ 		, V_INCFLDTIMEO
  		, V_RSHCMD
  		, V_RSHPATH
  		, V_RSHOPENTIMEO
***************
*** 808,813 ****
--- 814,821 ----
  #define VAR_INBOX_PATH		     vars[V_INBOX_PATH].current_val.p
  #define GLO_INBOX_PATH		     vars[V_INBOX_PATH].global_val.p
  #define VAR_INCOMING_FOLDERS	     vars[V_INCOMING_FOLDERS].current_val.l
+ #define VAR_INCOMING_FOLDERS_CHECK   vars[V_INCOMING_FOLDERS_CHECK].current_val.p
+ #define GLO_INCOMING_FOLDERS_CHECK   vars[V_INCOMING_FOLDERS_CHECK].global_val.p
  #define VAR_FOLDER_SPEC		     vars[V_FOLDER_SPEC].current_val.l
  #define GLO_FOLDER_SPEC		     vars[V_FOLDER_SPEC].global_val.l
  #define VAR_NEWS_SPEC		     vars[V_NEWS_SPEC].current_val.l
***************
*** 1000,1005 ****
--- 1008,1014 ----
  #define VAR_TCPREADWARNTIMEO	     vars[V_TCPREADWARNTIMEO].current_val.p
  #define VAR_TCPWRITEWARNTIMEO	     vars[V_TCPWRITEWARNTIMEO].current_val.p
  #define VAR_TCPQUERYTIMEO	     vars[V_TCPQUERYTIMEO].current_val.p
+ #define VAR_INCFLDTIMEO		     vars[V_INCFLDTIMEO].current_val.p
  #define VAR_RSHOPENTIMEO	     vars[V_RSHOPENTIMEO].current_val.p
  #define VAR_RSHPATH		     vars[V_RSHPATH].current_val.p
  #define VAR_RSHCMD		     vars[V_RSHCMD].current_val.p
***************
*** 1010,1015 ****
--- 1019,1026 ----
  #define VAR_BROWSER		     vars[V_BROWSER].current_val.l
  #define VAR_INCOMING_STARTUP	     vars[V_INCOMING_STARTUP].current_val.p
  #define GLO_INCOMING_STARTUP	     vars[V_INCOMING_STARTUP].global_val.p
+ #define VAR_INCOMING_RULE	     vars[V_INCOMING_RULE].current_val.p
+ #define GLO_INCOMING_RULE	     vars[V_INCOMING_RULE].global_val.p
  #define VAR_PRUNING_RULE	     vars[V_PRUNING_RULE].current_val.p
  #define GLO_PRUNING_RULE	     vars[V_PRUNING_RULE].global_val.p
  #define VAR_REOPEN_RULE		     vars[V_REOPEN_RULE].current_val.p
***************
*** 1144,1149 ****
--- 1155,1162 ----
  	F_DISABLE_PIPES_IN_TEMPLATES,
  	F_ATTACHMENTS_IN_REPLY,
  	F_ENABLE_INCOMING,
+ 	F_ENABLE_INCOMING_CHECK,
+ 	F_ENABLE_INCOMING_RECHECK,
  	F_NO_NEWS_VALIDATION,
  	F_QUELL_EXTRA_POST_PROMPT,
  	F_DISABLE_TAKE_LASTFIRST,
***************
*** 1167,1172 ****
--- 1180,1186 ----
  	F_VERTICAL_FOLDER_LIST,
  	F_TAB_CHK_RECENT,
  	F_AUTO_REPLY_TO,
+ 	F_SEPARATE_REPLY_ALL,
  	F_VERBOSE_POST,
  	F_FCC_ON_BOUNCE,
  	F_SEND_WO_CONFIRM,
***************
*** 1285,1290 ****
--- 1299,1306 ----
  	F_STRIP_WS_BEFORE_SEND,
  	F_QUELL_FLOWED_TEXT,
  	F_COMPOSE_ALWAYS_DOWNGRADE,
+ 	F_REMOVE_TRAILING_QUOTE,
+ 	F_QUELL_DISPLAYING_FLOWED_TEXT,
  #ifdef	_WINDOWS
  	F_ENABLE_TRAYICON,
  	F_QUELL_SSL_LARGEBLOCKS,
***************
*** 1501,1506 ****
--- 1517,1529 ----
  #define	IS_NOTSET			7	/* for reset version */
  
  /*
+  * Incoming check rules
+  */
+ #define	IC_AUTO		0
+ #define	IC_MAN_AUTO	1
+ #define	IC_MAN		2
+ 
+ /*
   * Pruning rules. If these grow, widen pruning_rule.
   */
  #define	PRUNE_ASK_AND_ASK		0
***************
*** 1782,1787 ****
--- 1805,1814 ----
  #define	SVAR_TCP_QUERY(ps, n, e) strtoval((ps)->VAR_TCPQUERYTIMEO, 	  \
  					 &(n), 5, 30000, 0, (e),	  \
  					"Tcp-Query-Timeout")
+ #define SVAR_INCFLDQUERY(ps, n, e) strtoval((ps)->VAR_INCFLDTIMEO,	\
+                                         &(n), 2, 60, 0, (e),		\
+                                        "Inc-fld-timeout")
+ 
  #define	SVAR_RSH_OPEN(ps, n, e)	strtoval((ps)->VAR_RSHOPENTIMEO, 	  \
  					 &(n), 5, 30000, 0, (e),	  \
  					"Rsh-Open-Timeout")
***************
*** 2511,2520 ****
--- 2538,2553 ----
      unsigned	    scanned:1;			/* scanned by c-client	      */
      unsigned	    parent:1;			/* visit parent		      */
      unsigned	    selected:1;			/* selected by user	      */
+     unsigned	    user_selected:1;		/* selected by user (not Pine)*/
      unsigned	    subscribed:1;		/* selected by user	      */
      unsigned long   varhash;			/* hash of var for incoming   */
      unsigned long   uidvalidity;		/* only for #move folder      */
      unsigned long   uidnext;			/* only for #move folder      */
+     int		    notified;			/* notified the change?	      */
+     long	    origrecent;			/* # recent messages in stream*/
+     long	    countrecent;		/* # recent messages displayed*/
+     long	    recent;			/* # recent messages adjusted */
+     long	    messages;			/* # messages		      */
      char	   *nickname;			/* folder's short name        */
      char	    name[1];			/* folder's name              */
  } FOLDER_S;
***************
*** 2871,2876 ****
--- 2904,2910 ----
  #define	MC_ADDABOOK	746
  #define	MC_DELABOOK	747
  #define	MC_VIEW_ENTRY	748
+ #define	MC_REPLY_ALL	749
  #define	MC_EDITABOOK	750
  #define	MC_OPENABOOK	751
  #define	MC_POPUP	752
***************
*** 2926,2931 ****
--- 2960,2967 ----
  /*
   * Some standard Key/Command Bindings 
   */
+ #define MC_IFAUTOCHECK	820
+ #define MC_FORCECHECK	821
  #define	NULL_MENU	{NULL, NULL, {MC_NONE}, KS_NONE}
  #define	HELP_MENU	{"?", "Help", \
  			 {MC_HELP, 2, {'?',ctrl('G')}}, \
***************
*** 2993,2998 ****
--- 3029,3037 ----
  #define	REPLY_MENU	{"R", "Reply", \
  			 {MC_REPLY,1,{'r'}}, \
  			 KS_REPLY}
+ #define	REPLY_ALL_MENU	{"=", "Reply All", \
+ 			 {MC_REPLY_ALL,1,{'='}}, \
+ 			 KS_REPLYALL}
  #define	FORWARD_MENU	{"F", "Forward", \
  			 {MC_FORWARD,1,{'f'}}, \
  			 KS_FORWARD}
***************
*** 4145,4150 ****
--- 4184,4198 ----
  
      char         cur_folder[MAXPATH+1];
      char         last_unambig_folder[MAXPATH+1];
+     char        *last_message;
+     int          refresh_list;
+     int          in_pico;
+     int		 in_indx;
+     int		 in_fld_list;
+     int		 force_check_now;
+     int          checking_incfld;
+     int          incfld_timeout;
+     int		 delay;
      ATTACH_S    *atmts;
      int          atmts_allocated;
      int	         remote_abook_validity;	/* minutes, -1=never, 0=only on opens */
***************
*** 4179,4184 ****
--- 4227,4233 ----
      unsigned     titlebar_color_style:3;
      unsigned	 fld_sort_rule:3;
      unsigned	 inc_startup_rule:3;
+     unsigned	 inc_check_rule:2;
      unsigned	 pruning_rule:3;
      unsigned	 reopen_rule:4;
      unsigned	 goto_default_rule:3;
***************
*** 4493,4504 ****
--- 4542,4558 ----
  char	   *folder_is_nick PROTO((char *, void *, int));
  char	   *next_folder PROTO((MAILSTREAM **, char *, char *,CONTEXT_S *,
  			       long *, int *));
+ char	   *next_folder_check PROTO((MAILSTREAM **, CONTEXT_S *, long *, long *,
+ 			       FOLDER_S *, int *));
  void	    init_inbox_mapping PROTO((char *, CONTEXT_S *));
  int	    news_build PROTO((char *, char **, char **, BUILDER_ARG *, int *));
  char	   *news_group_selector PROTO((char **));
  void	    free_newsgrp_cache PROTO(());
  char	   *context_edit_screen PROTO((struct pine *, char *, char *,
  				       char *, char *, char *));
+ void	    update_incoming_folder_data PROTO((MAILSTREAM *, CONTEXT_S *));
+ FOLDER_S   *incoming_folder_data PROTO((MAILSTREAM *, CONTEXT_S *));
+ int	    need_folder_report PROTO ((char *));
  SELECTED_S *new_selected PROTO((void));
  void	    free_selected PROTO((SELECTED_S **));
  int	    add_new_folder PROTO((CONTEXT_S *, EditWhich, int, char *, size_t,
***************
*** 4582,4587 ****
--- 4636,4642 ----
  NAMEVAL_S  *titlebar_col_style PROTO((int));
  NAMEVAL_S  *fld_sort_rules PROTO((int));
  NAMEVAL_S  *incoming_startup_rules PROTO((int));
+ NAMEVAL_S  *incoming_check_rules PROTO((int));
  NAMEVAL_S  *startup_rules PROTO((int));
  NAMEVAL_S  *pruning_rules PROTO((int));
  NAMEVAL_S  *reopen_rules PROTO((int));
***************
*** 4836,4841 ****
--- 4891,4900 ----
  void	    check_point_change PROTO((MAILSTREAM *));
  void	    reset_check_point PROTO((MAILSTREAM *));
  void	    zero_new_mail_count PROTO((void));
+ int	    new_mail_incfolder PROTO((struct pine *, int));
+ char	   *folder_in_list PROTO((char *));
+ int	    folder_in_message_list PROTO((char *));
+ char	   *new_mail_in_open_stream PROTO((MAILSTREAM *, long *, long *));
  int	    changes_to_checkpoint PROTO((MAILSTREAM *));
  
  /*-- os.c --*/
***************
*** 5024,5030 ****
  int         sp_nremote_permlocked PROTO((void));
  
  /*-- reply.c --*/
! void	    reply PROTO((struct pine *, ACTION_S *));
  void	    reply_seed PROTO((struct pine *, ENVELOPE *, ENVELOPE *,
  			      ADDRESS *, ADDRESS *, ADDRESS *, ADDRESS *,
  			      BUILDER_ARG *, int));
--- 5083,5089 ----
  int         sp_nremote_permlocked PROTO((void));
  
  /*-- reply.c --*/
! void	    reply PROTO((struct pine *, ACTION_S *, int));
  void	    reply_seed PROTO((struct pine *, ENVELOPE *, ENVELOPE *,
  			      ADDRESS *, ADDRESS *, ADDRESS *, ADDRESS *,
  			      BUILDER_ARG *, int));
***************
*** 5105,5113 ****
  void	    compose_screen PROTO((struct pine *)); 
  void	    alt_compose_screen PROTO((struct pine *)); 
  void	    compose_mail PROTO((char *, char *, ACTION_S *, PATMT *, gf_io_t));
! void	    pine_send PROTO((ENVELOPE *, BODY **, char *, ACTION_S *,
! 			     char *, REPLY_S *, REDRAFT_POS_S *, char *,
! 			     PINEFIELD *, int));
  int	    pine_simple_send PROTO((ENVELOPE *, BODY **, ACTION_S *, char *,
  				    char *, char **, int));
  char	   *pine_send_status PROTO((int, char *, char *, int *));
--- 5164,5172 ----
  void	    compose_screen PROTO((struct pine *)); 
  void	    alt_compose_screen PROTO((struct pine *)); 
  void	    compose_mail PROTO((char *, char *, ACTION_S *, PATMT *, gf_io_t));
! void	    pine_send PROTO((ENVELOPE *, ENVELOPE *, BODY **, char *,
! 			     ACTION_S *, char *, REPLY_S *, REDRAFT_POS_S *,
! 			     char *, PINEFIELD *, int));
  int	    pine_simple_send PROTO((ENVELOPE *, BODY **, ACTION_S *, char *,
  				    char *, char **, int));
  char	   *pine_send_status PROTO((int, char *, char *, int *));
diff -rc pine4.61/pine/pine.hlp pine4.61-cumulative/pine/pine.hlp
*** pine4.61/pine/pine.hlp	2004-07-15 10:37:22.000000000 -0700
--- pine4.61-cumulative/pine/pine.hlp	2005-02-22 14:02:00.000000000 -0800
***************
*** 3100,3105 ****
--- 3100,3106 ----
  <li><a href="h_config_quell_charset_warning">FEATURE: Quell-Charset-Warning</a>
  <li><a href="h_config_quell_content_id">FEATURE: Quell-Content-ID</a>
  <li><a href="h_config_quell_dead_letter">FEATURE: Quell-Dead-Letter-On-Cancel</a>
+ <li><a href="h_config_quell_displaying_flowed_text">FEATURE: Quell-Displaying-Flowed-Text</a>
  <li><a href="h_config_quell_empty_dirs">FEATURE: Quell-Empty-Directories</a>
  <li><a href="h_config_quell_post_prompt">FEATURE: Quell-Extra-Post-Prompt</a>
  <li><a href="h_config_quell_filtering_done_message">FEATURE: Quell-Filtering-Done-Message</a>
***************
*** 3127,3132 ****
--- 3128,3134 ----
  <li><a href="h_config_save_advances">FEATURE: Save-Will-Advance</a>
  <li><a href="h_config_save_wont_delete">FEATURE: Save-Will-Not-Delete</a>
  <li><a href="h_config_quote_all_froms">FEATURE: Save-Will-Quote-Leading-Froms</a>
+ <li><a href="h_config_remove_trailing_quote">FEATURE: Remove-Trailing-Quote-On-Send</a>
  <li><a href="h_config_scramble_message_id">FEATURE: Scramble-Message-ID</a>
  <li><a href="h_config_select_wo_confirm">FEATURE: Select-Without-Confirm</a>
  <li><a href="h_config_send_wo_confirm">FEATURE: Send-Without-Confirm</a>
***************
*** 17655,17660 ****
--- 17657,17679 ----
  be combined with the other fields if you'd like.
  
  <End of help on this topic>
+ ====== h_config_check_inc_fld ======
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: incoming-folders-to-check</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: incoming-folders-to-check</H1>
+ <P>
+ if you set this option and <A HREF="h_config_enable_check_incoming">
+ enable-check-incoming-folders</A> then you can use this option to write a space
+ separate list of incoming folders where you want new mail to be
+ checked. If you want all your incoming folders to be checked just write a
+ "*" as the value for this option.
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ======= h_address_format =======
  <HTML>
  <HEAD>
***************
*** 20638,20643 ****
--- 20657,20694 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_inc_fld_timeo =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: inc-fld-timeout</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: inc-fld-timeout</H1>
+ 
+ When Pine is checking for new mail in an external incoming folder, and the
+ amount of time specified in this variable has elapsed without Pine being
+ able to connect to the server holding that mailbox, Pine will drop the
+ connection to that server and continue checking for new mail in other
+ incoming folders, if any.
+ 
+ <P>
+ Observe that Pine will not print an error message in this case, but it
+ will silently drop the connection. If your connections are fast setting
+ this to a large value will not cause you any problem, but if your
+ connections are slow setting this to a small value will make Pine speed
+ checking for new mail, although it is possible that not all of your
+ incoming folders will be checked for new mail.
+ 
+ <P>
+ The default is 5 seconds, which is also the minimum and the maximum is 60.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_incoming_folders =====
  <HTML>
  <HEAD>
***************
*** 21860,21865 ****
--- 21911,21950 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_separate_reply_all =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Separate-Reply-All</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Separate-Reply-All</H1>
+ 
+ This option specifies an aspect of Pine's Reply command. Normally, Pine offers
+ a single reply command; if you reply to an email with multiple recipients, Pine
+ asks you whether you want to reply to all recipients, or just to the sender.
+ 
+ <P>
+ If this option is set, the standard reply command will always reply to the
+ sender (or reply-to address). A separate reply-to-all command will be offered,
+ which will always reply to all recipients.
+ 
+ <P>
+ This option is intended to discourage unintentional replying to all. Users
+ often inadvertently train themselves to "click past" prompts, such as Pine's
+ "reply to all recipients?" prompt. This reduces their effectiveness. Separating
+ the reply and reply-to-all commands may alleviate this problem.
+ 
+ <P>
+ Note: the reply-to-all command is not offerred in the attachment index or
+ attachment view, but if this option is set, the standard reply command in those
+ screens will still only reply to the sender.
+ 
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_empty_hdr_msg =====
  <HTML>
  <HEAD>
***************
*** 22953,22958 ****
--- 23038,23088 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_inc_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Incoming-Check-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Incoming-Check-Rule</H1>
+ 
+ This value affects Pine's behavior when starting Pine. It determines
+ how and when Pine will check for new mail in your incoming folders. The
+ default value is &quot;automatic&quot;.
+ 
+ <P>
+ The three possible values for this option are:
+ 
+ <DL>
+ <DT>automatic</DT>
+ <DD>This is the default. When this is selected the first check for new
+ mail will be done when Pine is starting up and you either go to the
+ INDEX or FOLDER LIST screens.
+ </DD>
+ 
+ <DT>automatic-after-first-manual-check</DT>
+ <DD>Similar to the default, but no check is done until you force the first
+ one by pressing CTRL-H. All checks are automatic after the first one. Observe
+ that this feature does not work once an automatic check has been done.
+ </DD>
+ 
+ <DT>manual-only</DT>
+ <DD>This forces Pine to do only manual checks. This will probably speed
+ Pine, since checks will  only happen when they are forced by pressing CTRL-H.
+ </DD>
+ </DL>
+ 
+ <P>
+ If you just want to stop Pine from checking in one folder, then simply
+ select that folder. Checks on that folder will be skipped.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_browser =====
  <HTML>
  <HEAD>
***************
*** 23894,23899 ****
--- 24024,24106 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_enable_check_incoming ======
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: enable-check-incoming-folders</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: enable-check-incoming-folders</H1>
+ If you have enabled <A HREF="h_config_enable_incoming">incoming
+ folders</A> then setting this feature allows you to check for new mail in
+ these. A message stating that new mail was received and in which folders
+ will be written in the screen. You can decide which incoming folders you
+ want to check for new mail, and the list of them has to be entered in the
+ setting <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>.
+ 
+ <P> If you have the option 
+ <A HREF="h_config_fast_recent">enable-fast-recent-test</A>
+ <B>disabled</B>, but have this feature enabled, then a full report on the
+ total number of messages, and the number of new messages in the folder is
+ printed in the <A HREF="h_folder_maint">FOLDER LIST</A> screen 
+ for each folder listed in the variable 
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>. The report for each
+ folder is made in the format
+ 
+ <P>
+ folder-name [Number of new messages/Number of messages in the folder]
+ 
+ <P>
+ If an incoming folder is not listed in the variable
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>, then only 
+ the name of the folder and no other report is made about that folder.
+ 
+ <P>
+ Other important features related to this feature are:
+ <OL>
+ <LI><A HREF="h_config_enable_recheck_incoming">recheck-all-incoming-folders</A>,
+ which allows you to decide if you want to check all folders every check,
+ <LI><A HREF="h_config_inc_rule">incoming-check-rule</A>, which determines
+ how and when Pine will check for new mail in your incoming folders.
+ </OL>
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ </BODY>
+ </HTML>
+ ====== h_config_enable_recheck_incoming ======
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: recheck-all-incoming-folders</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: recheck-all-incoming-folders</H1>
+ If you have enabled <A HREF="h_config_enable_incoming">incoming folders</A>
+ and <A HREF="h_config_enable_check_incoming">enable-check-incoming-folder</A>
+ then setting this feature will force Pine to recheck all incoming folders
+ for new mail. The normal behavior (that is to say, when this feature
+ is not enabled) is that Pine will skip checking for new mail in folders
+ where it already found. This is done to speed checking for new mail.
+ 
+ <P>
+ The default behavior, however, can cause problems if you use two clients
+ to access the same incoming folders, because Pine will not realize that
+ new mail does not exist in one folder where it already reported new mail,
+ but was opened with the other client. Setting this feature will cause Pine
+ to recheck all folders all the time. In this way Pine will know for sure
+ which folders DO contain new mail.
+ 
+ <P> If you only use Pine to access your incoming folders, then DO NOT
+ enable this feature.
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ </BODY>
+ </HTML>
  ====== h_config_attach_in_reply ======
  <HTML>
  <HEAD>
***************
*** 24334,24339 ****
--- 24541,24573 ----
  successes.  You will usually receive the full message back when there is
  a failure.
  
+ <P> When this feature is <B>disabled</B>, and the feature 
+ <A HREF="h_config_enable_check_incoming">enable-check-incoming-folders</A>
+ is enabled, then a full report of the number of messages and number of
+ new messages in each incoming folder listed in the option
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A> is made. This
+ report is printed in the <A HREF="h_folder_maint">FOLDER LIST</A> screen. The 
+ report is given in the form
+ 
+ <P>
+ folder-name [Number of New Messages/Number of messages in the folder]
+ 
+ <P> If an incoming-folder is not listed in the variable 
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>, no check for
+ that folder is made, so only the folder name, and no other information is
+ printed about that folder.
+ 
+ <P> If this feature is enabled and the feature 
+ <A HREF="h_config_enable_recheck_incoming">recheck-all-incoming-folders</A>
+ is disabled, then selecting a folder will cancel further checks on that
+ folder. This is useful if checks to a particular incoming folder are slow
+ and want to be avoided (until the folder is unselected and a new cycle of
+ checks is done) without changing the list of folders to be checked.
+ Selecting a folder in order to avoid checks for new mail does not work in
+ other cases, since it is either explicitly requested this way or because
+ it is necessary to update the count of new and total number of messages of
+ every requested folder.
+ 
  <P>
  If you turn on the DSNOpts the default is to return as much information as
  possible to you.  That is, by default, the Success and Delay options are
***************
*** 25245,25250 ****
--- 25479,25504 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_quell_displaying_flowed_text =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: Quell-Displaying-Flowed-Text</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: Quell-Displaying-Flowed-Text</H1>
+ 
+ Beginning with version 4.60, Pine displays flowed text where possible. The
+ method for viewing flowed text is defined by
+ <A HREF="http://www.ietf.org/rfc/rfc2646.txt">RFC 2646</A>; for more
+ information, see <A HREF="h_config_quell_flowed_text">Quell-Flowed-Text</A>.
+ <P>
+ If this option is set, then Pine will not display flowed text when viewing
+ messages.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_prefer_plain_text =====
  <HTML>
  <HEAD>
***************
*** 26603,26608 ****
--- 26857,26911 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_remove_trailing_quote =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: Remove-Trailing-Quote-On-Send</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: Remove-Trailing-Quote-On-Send</H1>
+ 
+ If set, this feature removes trailing quotes from compositions before sending.
+ It also enables you to remove a trailing quote manually at any time by pressing
+ Ctrl-4.
+ 
+ <P>
+ A quote is a piece of text quoted from an email that you're replying to. A
+ quote is considered trailing if it's the last piece of text in the composition,
+ except for (possibly) your signature. For example, this composition has a
+ trailing quote:
+ 
+ <P>
+ <PRE>
+ --
+ On Fri, 4 Jun 2004, Jane Doe wrote:
+ 
+ > Thanks for the invitation! Should I bring anything?
+ 
+ No, I have everything I need. Thanks though!
+ 
+ > I'll see you soon...
+ >
+ > -Jane
+ --
+ </PRE>
+ 
+ <P>
+ If the last quote is preceded by the reply leadin line, usually something like 
+ "<SAMP>On Oct 27 Fred Flintstone wrote:</SAMP>", then it is considered a
+ "whole" quote, and is not removed. The author probably intentionally included
+ the whole quote or may be top-posting.
+ 
+ <P>
+ This feature was added to make it easier to observe proper netiquette when
+ quoting. If you want to quote the smallest relevant piece of an email, you
+ often need to delete a significant amount of quoted text. This is especially
+ true if you correspond with people who top-post.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_normal_color =====
  <HTML>
  <HEAD>
Only in pine4.61-cumulative/pine: pine.hlp.orig
Only in pine4.61-cumulative/pine: pine.h.orig
diff -rc pine4.61/pine/reply.c pine4.61-cumulative/pine/reply.c
*** pine4.61/pine/reply.c	2004-07-13 18:35:20.000000000 -0700
--- pine4.61-cumulative/pine/reply.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 146,154 ****
     - pass off to pine_send()
    ---*/
  void
! reply(pine_state, role_arg)
       struct pine *pine_state;
       ACTION_S    *role_arg;
  {
      ADDRESS    *saved_from, *saved_to, *saved_cc, *saved_resent;
      ENVELOPE   *env, *outgoing;
--- 146,155 ----
     - pass off to pine_send()
    ---*/
  void
! reply(pine_state, role_arg, flags)
       struct pine *pine_state;
       ACTION_S    *role_arg;
+      int         flags;
  {
      ADDRESS    *saved_from, *saved_to, *saved_cc, *saved_resent;
      ENVELOPE   *env, *outgoing;
***************
*** 158,164 ****
      char       *tmpfix = NULL, *prefix = NULL;
      long        msgno, totalm, rflags, *seq = NULL;
      int         i, include_text = 0, times = -1, warned = 0,
! 		flags = RSF_QUERY_REPLY_ALL, reply_raw_body = 0;
      gf_io_t     pc;
      PAT_STATE   dummy;
      REDRAFT_POS_S *redraft_pos = NULL;
--- 159,165 ----
      char       *tmpfix = NULL, *prefix = NULL;
      long        msgno, totalm, rflags, *seq = NULL;
      int         i, include_text = 0, times = -1, warned = 0,
!                 reply_raw_body = 0;
      gf_io_t     pc;
      PAT_STATE   dummy;
      REDRAFT_POS_S *redraft_pos = NULL;
***************
*** 657,663 ****
  #endif
  
      /* partially formatted outgoing message */
!     pine_send(outgoing, &body, "COMPOSE MESSAGE REPLY",
  	      role, fcc.tptr, &reply, redraft_pos, NULL, NULL, 0);
    done:
      pine_free_body(&body);
--- 658,664 ----
  #endif
  
      /* partially formatted outgoing message */
!     pine_send(env, outgoing, &body, "COMPOSE MESSAGE REPLY",
  	      role, fcc.tptr, &reply, redraft_pos, NULL, NULL, 0);
    done:
      pine_free_body(&body);
***************
*** 3907,3913 ****
  #if	defined(DOS) && !defined(_WINDOWS)
      free((void *)reserve);
  #endif
!     pine_send(outgoing, &body, "FORWARD MESSAGE",
  	      role, NULL, reply.flags ? &reply : NULL, redraft_pos,
  	      NULL, NULL, FALSE);
  
--- 3908,3914 ----
  #if	defined(DOS) && !defined(_WINDOWS)
      free((void *)reserve);
  #endif
!     pine_send(env, outgoing, &body, "FORWARD MESSAGE",
  	      role, NULL, reply.flags ? &reply : NULL, redraft_pos,
  	      NULL, NULL, FALSE);
  
***************
*** 4404,4410 ****
  		     source);
  
  	if((enc_error = gf_pipe(gc, pc)) == NULL){
! 	    pine_send(env, &body, "SEND MESSAGE", role, NULL, NULL, NULL,
  		      NULL, NULL, FALSE);
  	    pine_state->mangled_screen = 1;
  	}
--- 4405,4411 ----
  		     source);
  
  	if((enc_error = gf_pipe(gc, pc)) == NULL){
! 	    pine_send(NULL, env, &body, "SEND MESSAGE", role, NULL, NULL, NULL,
  		      NULL, NULL, FALSE);
  	    pine_state->mangled_screen = 1;
  	}
***************
*** 5915,5920 ****
--- 5916,5922 ----
      pbf.always_spell_check = F_ON(F_ALWAYS_SPELL_CHECK, ps_global);
      pbf.strip_ws_before_send = F_ON(F_STRIP_WS_BEFORE_SEND, ps_global);
      pbf.allow_flowed_text = 0;
+     pbf.remove_trailing_quote = 0;
  
      pbf.pine_anchor   = set_titlebar(title,
  				      ps_global->mail_stream,
***************
*** 6103,6108 ****
--- 6105,6111 ----
      pbf.always_spell_check = F_ON(F_ALWAYS_SPELL_CHECK, ps_global);
      pbf.strip_ws_before_send = F_ON(F_STRIP_WS_BEFORE_SEND, ps_global);
      pbf.allow_flowed_text = 0;
+     pbf.remove_trailing_quote = 0;
  
      pbf.pine_anchor   = set_titlebar(title,
  				      ps_global->mail_stream,
diff -rc pine4.61/pine/send.c pine4.61-cumulative/pine/send.c
*** pine4.61/pine/send.c	2004-06-30 11:28:02.000000000 -0700
--- pine4.61-cumulative/pine/send.c	2005-02-22 14:02:00.000000000 -0800
***************
*** 980,986 ****
  	  fs_give((void **)&tmp_fcc);
      }
  
!     pine_send(outgoing, &body, COMPOSE_MAIL_TITLE, role, fcc,
  	      reply, redraft_pos, lcc, custom, fcc_is_sticky);
  
      if(reply){
--- 980,986 ----
  	  fs_give((void **)&tmp_fcc);
      }
  
!     pine_send(NULL, outgoing, &body, COMPOSE_MAIL_TITLE, role, fcc,
  	      reply, redraft_pos, lcc, custom, fcc_is_sticky);
  
      if(reply){
***************
*** 1001,1006 ****
--- 1001,1009 ----
      if(lcc)
        fs_give((void **)&lcc);
  
+     if(sig)
+       fs_give((void **)&sig);
+ 
      mail_free_envelope(&outgoing);
      pine_free_body(&body);
      free_redraft_pos(&redraft_pos);
***************
*** 3116,3123 ****
  stored in a storage object (see filter.c).
    ----*/
  void
! pine_send(outgoing, body, editor_title, role, fcc_arg, reply, redraft_pos,
! 	  lcc_arg, custom, sticky_fcc)
      ENVELOPE  *outgoing;  /* c-client envelope for outgoing message */
      BODY     **body;   
      char      *editor_title;
--- 3119,3127 ----
  stored in a storage object (see filter.c).
    ----*/
  void
! pine_send(reply_env, outgoing, body, editor_title, role, fcc_arg, reply,
! 	  redraft_pos, lcc_arg, custom, sticky_fcc)
!     ENVELOPE  *reply_env;  /* may be NULL */
      ENVELOPE  *outgoing;  /* c-client envelope for outgoing message */
      BODY     **body;   
      char      *editor_title;
***************
*** 3135,3140 ****
--- 3139,3145 ----
      char	       *start_here_name = NULL;
      char               *suggested_nntp_server = NULL;
      char	       *title = NULL;
+     char	       reply_leadin[2000];
      struct headerentry *he, *headents, *he_to, *he_fcc, *he_news, *he_lcc,
  		       *he_from = NULL;
      PINEFIELD          *pfields, *pf, *pf_nobody = NULL,
***************
*** 3148,3153 ****
--- 3153,3159 ----
      STORE_S	       *orig_so = NULL;
      PICO	        pbuf1, *save_previous_pbuf;
      REDRAFT_POS_S      *local_redraft_pos = NULL;
+     gf_io_t	       reply_leadin_pc;
  #ifdef	DOS
      char               *reserve;
  #endif
***************
*** 3206,3211 ****
--- 3212,3218 ----
  			      && F_OFF(F_STRIP_WS_BEFORE_SEND, ps_global)
  			      && (strcmp(pbf->quote_str, "> ") == 0
  				  || strcmp(pbf->quote_str, ">") == 0));
+     pbf->remove_trailing_quote = F_ON(F_REMOVE_TRAILING_QUOTE, ps_global);
      pbf->edit_offset   = 0;
      title               = cpystr(set_titlebar(editor_title,
  				    ps_global->mail_stream,
***************
*** 3213,3218 ****
--- 3220,3236 ----
  				    ps_global->cur_folder,ps_global->msgmap, 
  				    0, FolderName, 0, 0, NULL));
      pbf->pine_anchor   = title;
+     pbf->sig           = detoken(role, outgoing, 0, 0, 1, NULL, NULL);
+ 
+     if(reply_env){
+ 	gf_set_writec(&reply_leadin_pc, reply_leadin, 2000L, CharStar);
+ 	reply_delimiter(reply_env, role, reply_leadin_pc);
+ 	/* strip two trailing newlines */
+ 	reply_leadin[strlen(reply_leadin) - 2] = '\0';
+ 	pbf->reply_leadin = cpystr(reply_leadin);
+     }
+     else
+ 	pbf->reply_leadin = NULL;
  
  #if	defined(DOS) || defined(OS2)
      if(!pbf->oper_dir && ps_global->VAR_FILE_DIR){
***************
*** 3295,3300 ****
--- 3313,3322 ----
  	      case 'x': /* ^C */
  		q_status_message(SM_ORDER, 0, 3, "Message cancelled");
  		dprint(4, (debugfile, "=== send: cancelled\n"));
+ 		if (pbf->sig)
+ 		    fs_give((void **)&pbf->sig);
+ 		if (pbf->reply_leadin)
+ 		    fs_give((void **)&pbf->reply_leadin);
  		pbf = save_previous_pbuf;
  		return;
  
***************
*** 4250,4258 ****
--- 4272,4283 ----
  	/* turn off user input timeout when in composer */
  	saved_user_timeout = ps_global->hours_to_timeout;
  	ps_global->hours_to_timeout = 0;
+ 	ps_global->in_pico = 1; /* in */
  	dprint(1, (debugfile, "\n  ---- COMPOSER ----\n"));
  	editor_result = pico(pbf);
+ 	ps_global->force_check_now = 0; /* do not check incoming folders now */
  	dprint(4, (debugfile, "... composer returns (0x%x)\n", editor_result));
+ 	ps_global->in_pico = 0; /* out */
  	ps_global->hours_to_timeout = saved_user_timeout;
  
  #if	defined(DOS) && !defined(_WINDOWS)
***************
*** 5198,5203 ****
--- 5223,5234 ----
  
      free_attachment_list(&pbf->attachments);
  
+     if(pbf->sig)
+ 	fs_give((void **)&pbf->sig);
+ 
+     if (pbf->reply_leadin)
+ 	fs_give((void **)&pbf->reply_leadin);
+ 
      standard_picobuf_teardown(pbf);
  
      for(i=0; i < fixed_cnt; i++){
Only in pine4.61-cumulative/pine: send.c.orig
diff -rc pine4.61/pine/signals.c pine4.61-cumulative/pine/signals.c
*** pine4.61/pine/signals.c	2004-05-07 15:56:50.000000000 -0700
--- pine4.61-cumulative/pine/signals.c	2005-02-22 14:01:51.000000000 -0800
***************
*** 675,681 ****
  
  		add_review_message(buf, -1);
  	    }
! 	    else{
  		q_status_message(SM_ORDER, 0, 1, progress);
  
  		/*
--- 675,681 ----
  
  		add_review_message(buf, -1);
  	    }
! 	    else if (!ps_global->checking_incfld){
  		q_status_message(SM_ORDER, 0, 1, progress);
  
  		/*
***************
*** 696,702 ****
      }
  
      /* set alarm */
!     if(F_OFF(F_DISABLE_ALARM, ps_global))
        alarm(seconds);
  
      return(retval);
--- 696,702 ----
      }
  
      /* set alarm */
!     if(F_OFF(F_DISABLE_ALARM, ps_global) && (!ps_global->checking_incfld))
        alarm(seconds);
  
      return(retval);
***************
*** 735,740 ****
--- 735,741 ----
  		left  = slots_used - 4 - right;
  		sprintf(progress, "%s |%*s100%%%*s|",
  		    busy_message, left, "", right, "");
+ 		if (!ps_global->checking_incfld)
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
  		    message_pri+2, progress);
***************
*** 742,747 ****
--- 743,749 ----
  	    else{
  		sprintf(progress, "%s%*sDONE", busy_message,
  		    DISPLAY_CHARS_COLS - 4 + 1, "");
+ 		if (!ps_global->checking_incfld)
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
  		    message_pri+2, progress);
